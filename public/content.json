{"meta":{"title":"Scala-Play","subtitle":null,"description":null,"author":"scala-play.com","url":"https://scala-play.com"},"pages":[],"posts":[{"title":"Scala – Lists","slug":"scala-list","date":"2018-10-08T02:11:35.000Z","updated":"2018-10-08T09:52:39.780Z","comments":true,"path":"2018/10/08/scala-list/","link":"","permalink":"https://scala-play.com/2018/10/08/scala-list/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;List trong scala gần tương tự như mảng, vì mọi phần tử đều cùng kiểu dữ liệu nhưng lại có hai sự khác biệt quan trọng: Đầu tiên, List không thể thay đổi, có nghĩa những phần tử trong một List không thể thay đổi được bằng phép gán. Thứ hai, List đại diện cho một danh sách liên kết các phần tử, trong khi đó các phần tử của array(mảng) đước xếp cạnh, liên tiếp với nhau. Kiểu của một List được viết duới dạng : List[T]. Bạn hãy xem thử ví dụ dưới đây, một vài List được định nghĩa cho các kiểu dữ liệu khác nhau. 12345678910111213141516// List of Stringsval fruit: List[String] = List(\"apples\", \"oranges\", \"pears\")// List of Integersval nums: List[Int] = List(1, 2, 3, 4)// Empty List.val empty: List[Nothing] = List()// Two dimensional listval dim: List[List[Int]] = List( List(1, 0, 0), List(0, 1, 0), List(0, 0, 1) ) Tất cả List được định nghĩa với hai khối cơ bản là :: và Nil ở cuối. Nil cũng biểu thị một danh sách trống. Tất cả List trên được định nghĩa như sau: 12345678910// List of Stringsval fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil))// List of Integersval nums = 1 :: (2 :: (3 :: (4 :: Nil)))// Empty List.val empty = Nil// Two dimensional listval dim = (1 :: (0 :: (0 :: Nil))) :: (0 :: (1 :: (0 :: Nil))) :: (0 :: (0 :: (1 :: Nil))) :: Nil Thao tác cơ bản trên Lists Tất cả thao tác trên List được thể hiện theo ba phương thức sau đây: No Phương thức &amp; Mô tả 1 head: Phương thức này trả về phần tử đầu tiên của list. 2 tail: Phương thức này trả về 1 danh sách gồm tất cả phần tử ngoại trừ phần tử đầu tiên. 3 isEmpty: Phương thức này trả về true nếu list rỗng, và ngược lại trả về false. Ví dụ sau cho ta thấy cách dùng các phương thức trên. Ví dụ: 12345678910 object Demo &#123; def main(args: Array[String]) &#123; val fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) val nums = Nil println( \"Head of fruit : \" + fruit.head ) println( \"Tail of fruit : \" + fruit.tail ) println( \"Check if fruit is empty : \" + fruit.isEmpty ) println( \"Check if nums is empty : \" + nums.isEmpty ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1234Head of fruit : applesTail of fruit : List(oranges, pears)Check if fruit is empty : falseCheck if nums is empty : true Ghép nối các List Bạn có thể dùng hoặc phép toán ::: hoặc phương thức List.:::() hoặc List.concat() để thêm hai hoặc nhiều List trở lên. Vui lòng khám phá ví dụ dưới đây Ví dụ123456789101112131415object Demo &#123; def main(args: Array[String]) &#123; val fruit1 = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) val fruit2 = \"mangoes\" :: (\"banana\" :: Nil) // dùng 2 hay nhiều list với toán tử ::: var fruit = fruit1 ::: fruit2 println( \"fruit1 ::: fruit2 : \" + fruit ) // dùng 2 list với phương thức Set.:::() fruit = fruit1.:::(fruit2) println( \"fruit1.:::(fruit2) : \" + fruit ) // truyền hai hay nhiều list làm tham số fruit = List.concat(fruit1, fruit2) println( \"List.concat(fruit1, fruit2) : \" + fruit ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Những lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả123fruit1 ::: fruit2 : List(apples, oranges, pears, mangoes, banana)fruit1.:::(fruit2) : List(mangoes, banana, apples, oranges, pears)List.concat(fruit1, fruit2) : List(apples, oranges, pears, mangoes, banana) Tạo List đồng nhất Bạn có thể dùng phương thức List.fill() để tạo một 0 hoặc nhiều bản sao của các phần tử . Hãy thử chương trình ví dụ sau đây. Ví dụ:123456789object Demo &#123; def main(args: Array[String]) &#123; val fruit = List.fill(3)(\"apples\") // Repeats apples three times. println( \"fruit : \" + fruit ) val num = List.fill(10)(2) // Repeats 2, 10 times. println( \"num : \" + num ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:12fruit : List(apples, apples, apples)num : List(2, 2, 2, 2, 2, 2, 2, 2, 2, 2) Tạo bảng một hàm Bạn có thể dùng một hàm cùng với phương thức List.tabulate() để tác dụng lên tất cả phần tử của List trước khi tạo bảng List. Tham số của hàm này giống như phương thức List.fill: Tham số thứ nhất cho biết kích thước List cần tạo, và tham số thứ hai mô tả các phần tử của List. Sự khác biệt duy nhất là thay vì phần tử cố định , chúng được tính từ một hàm. Thử chương trình ví dụ sau đây Ví dụ:123456789object Demo &#123; def main(args: Array[String]) &#123; // Creates 5 elements using the given function. val squares = List.tabulate(6)(n =&gt; n * n) println( \"squares : \" + squares ) val mul = List.tabulate( 4,5 )( _ * _ ) println( \"mul : \" + mul ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả123squares : List(0, 1, 4, 9, 16, 25)mul : List(List(0, 0, 0, 0, 0), List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8), List(0, 3, 6, 9, 12)) Đảo ngược thứ tự List Bạn có thể dùng phương thức List.reverse để đảo ngược tất cả phần tử trong danh sách. Ví dụ sau đây cho thấy cách dùng nó. Ví dụ:1234567object Demo &#123; def main(args: Array[String]) &#123; val fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) println( \"Before reverse fruit : \" + fruit ) println( \"After reverse fruit : \" + fruit.reverse ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:12Before reverse fruit : List(apples, oranges, pears)After reverse fruit : List(pears, oranges, apples) Các phương thức của List trong scala Sau đây là những phương thức quan trọng khi bạn dùng khi thao tác với các List. Đối với một danh sách hoàn chỉnh các phương thức có sẵn, hãy kiểm tra tài liệu chính thức của Scala. Sr.No Phương thức với mô tả của nó 1 scala def +(elem: A): List[A] Thêm một phần tử vào đầu list 2 def :::(prefix: List[A]): List[A] Thêm những phần tử của list được truyền, vào trước list ban đầu 3 def ::(x: A): List[A] Thêm một phần tử x vào đầu của list 4 def addString(b: StringBuilder): StringBuilder Gán tất cả phần tử của list vào chuỗi StringBuilder 5 def addString(b: StringBuilder, sep: String): StringBuilder Gán tất cả phần tử của list vào chuỗi StringBuilder b và ngăn cách lần lượt bởi chuỗi sep 6 def apply(n: Int): A Chỉ định và trả về một phần tử bởi chỉ số của nó trong list 7 def contains(elem: Any): Boolean Kiểm tra giá trị được truyền có là một phần tử trong list không. 8 def copyToArray(xs: Array[A], start: Int, len: Int): Unit Sao chép tất cả phần tử của list sang 1 mảng. Tham số cần truyền thêm là vị trí bắt đầu được sao chép sang trong mảng, và độ dài của list. 9 def distinct: List[A] Trả về một list mới từ list đã cho mà không chứa bất kỳ phần tử trùng nào. 10 def drop(n: Int): List[A] Trả về list chứa tất cả phần tử ngoại trừ n phần tử đầu tiên. 11 def dropRight(n: Int): List[A] Trả về list chứa tất cả phần tử ngoại trừ n phần tử cuối cùng. 12 def endsWith[B](that: Seq[B]): Boolean Kiểm tra list có kết thúc với danh sách Seq[] truyền vào hay không. 13 def equals(that: Any): Boolean Phương thức tương tự với các danh sách tùy ý. So sánh danh sách này với một số đối tượng khác. 14 def filter(p: (A) =&gt; Boolean): List[A] Trả về tất cả phần tử trong list thỏa mãn vị từ. 15 def foreach(f: (A) =&gt; Unit): Unit Áp dụng hàm f cho tất cả các phần tử của list. 16 def head: A Chỉ định phần tử đầu tử đầu tiên của list. 17 def indexOf(elem: A, from: Int): Int Tìm vị trí xuất hiện đầu tiên của giá trị A trong list ,kể từ vị trí from trở đi. 18 def init: List[A] Trả về list chứa tất cả phần tử ngoại trừ phần tử cuối cùng. 19 def isEmpty: Boolean Kiểm tra xem list có rỗng không 20 def iterator: Iterator[A] Tạo một trình lặp mới trên tất cả phần tử có trong đối tượng iterable có thể lặp 21 def last: A Trả về phần tử cuối cùng 22 def lastIndexOf(elem: A, end: Int): Int Tìm vị trí xuất hiện cuối cùng của một số giá trị trong list ,trước hoặc tại vị trí end . 23 def length: Int Trả về độ dài của list. 24 def map[B](f: (A) =&gt; B): List[B] Trả về một list mới bằng việc áp dụng hàm f cho tất cả phần tử của list. 25 def max: A Tìm phần tử lớn nhất. 26 def min: A Tìm phần tử nhỏ nhất. 27 def mkString: String Hiển thị ra tất cả phần tử của list dưới dạng một chuỗi. 28 def mkString(sep: String): String Hiển thị ra tất cả phần tử của list trong một chuỗi dùng 1 chuỗi ngăn cách sep 29 def reverse: List[A] Trả về một list mới với các phần tử được đảo ngược. 30 def sorted[B &gt;: A]: List[A Sắp xếp list theo một thứ tự. 31 def startsWith[B](that: Seq[B], offset: Int): Boolean Kiểm tra xem list có chứa danh sách truyền vào tại một vị trí offset không. 32 def sum: A Tính tổng tất cả phần tử của tập hợp. 33 def tail: List[A] Trả về tất cả phần tử ngoại trừ phần tử đầu tiên. 34 def take(n: Int): List[A] Trả về n phần tử đầu tiên. 35 def takeRight(n: Int): List[A] Trả về n phần tử cuối cùng. 36 def toArray: Array[A] Ép kiểu list sang kiểu mảng array. 37 def toBuffer[B &gt;: A]: Buffer[B] Ép kiểu list sang một bộ đệm có thể thay đổi. 38 def toMap[T, U]: Map[T, U] Chuyển đổi list sang một map 39 def toSeq: Seq[A] Chuyển đổi list sang một danh sách sequence. 40 def toSet[B &gt;: A]: Set[B] Chuyển đổi list sang một Set. 41 def toString(): String Chuyển đổi list sang một chuỗi.","categories":[],"tags":[]},{"title":"Hướng dẫn sử dụng Gitlab-CI/CD","slug":"git-lab","date":"2018-10-06T03:48:07.000Z","updated":"2018-10-06T05:23:12.951Z","comments":true,"path":"2018/10/06/git-lab/","link":"","permalink":"https://scala-play.com/2018/10/06/git-lab/","excerpt":"","text":"1. Các chức năng chính Tự động Build và Deploy lên Staging (đã sử dụng được) Tự động Build và Deploy lên Production (đang phát triển) - Chức năng tự động Build và Deploy lên Staging sẽ được kích hoạt khi merge code vàobranch “dev” hoặc push code lên branch “dev”. - Chức năng tự động Build và Deploy lên Production sẽ được kích hoạt khi merge code vàobranch “master” hoặc push code lên branch “master”. 2. Cách sử dụngBước 1: merge code vào branch “dev” hoặc push code lên branch “dev” Bước 2: chờ quá trình Build - Deploy diễn raBước 2.1: Đầu tiên, chúng ta vào mục “Pipelines” để kiểm tra trạng thái của quá trình. Bước 2.2: Nhấn vào “running” để đi tới màn hình chi tiết của quá trình. Bước 2.3: ​ Nhấn vào “staging” để đi tới màn hình console - nơi hiển thị chi tiết quá trình build và deploy dự án lên Staging. - Sau bước này, chúng ta sẽ có kết quả của quá trình Build -&gt; Deploy. Sẽ có hai trường hợp xảy ra: Quá trình xảy ra lỗi: Gitlab-CI/CD sẽ báo trạng thái của quá trình sẽ hiển thị giống như . Hoặc hiển thị “ERROR: Job failed: exit code 1” trên màn hình console ở dòng cuối cùng. Quá trình diễn ra thành công: trạng thái sẽ là . Bước 3: xử lý kết quả của quá trình Build - Deploy Bước 3.1: N​ ếu kết quả trả về là thành công . Chúng ta sẽ lên Staging server để xemkết quả, công việc triển khai coi như xong. Ngoài ra, chúng ta có thể xem chi tiết hơn bằngcách: - Vào mục “Builds” để xem tất cả các quá trình Build - Deploy đã thực hiện (bao gồm cả quátrình thực thi lại một lần Build - Deploy nào đó) - Vào mục “Environments” để xem các môi trường đã triển khai. Ở đây, chúng ta mới triểnkhai lên môi trường Staging. Môi trường Production sẽ được triển khai sau… Bước 3.2: Nếu kết quả trả lỗi, chúng ta nên đọc lại phần thông tin hiển thi ở màn hình console trước để tìm ra nguyên nhân. Sau đó đi tới mục “related-code” để xem chi tiết đoạn code nào đã gây lỗi cho hệ thống.","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-05T11:03:34.970Z","updated":"2018-10-05T11:03:34.970Z","comments":true,"path":"2018/10/05/hello-world/","link":"","permalink":"https://scala-play.com/2018/10/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://scala-play.com/tags/hello/"}]},{"title":"Higher Order Functions trong Scala","slug":"HOF-in-scala","date":"2018-10-02T13:08:24.000Z","updated":"2018-10-06T04:02:00.858Z","comments":true,"path":"2018/10/02/HOF-in-scala/","link":"","permalink":"https://scala-play.com/2018/10/02/HOF-in-scala/","excerpt":"","text":"Định nghĩa Higher Order FunctionHigher Order Function là function thỏa mãn ít nhất một trong hai điều kiện : Có ít nhất một tham số truyền vào là một function khác Kết quả trả về của HOF đó là một function khác. Với Higher Order Function, tính trừu tượng hóa, tái sử dụng chính là điểm mạnh. Tính trừu tượng hóa (Abstraction)Hãy nghĩ đến dây chuyền lắp ráp một chiếc xe. Dây chuyền gồm bốn bộ phận: Bộ phận tạo bánh xe Bộ phận tạo khung xe Bộ phận tạo động cơ Bộ phận lắp ráp Bộ phận tạo bánh xe sẽ tạo ra bánh xe và chuyển qua bộ phận lắp. Tương tự như vậy, bộ phận tạo khung xe và bộ phân tạo động cợ sẽ tạo ra khung và động cơ, sau đó chuyển sang cho bộ phân lắp ráp. Bộ phận lắp ráp không cần phải biết bánh xe, khung xe hay động cơ xe được tạo ra như thế nào. Chức năng của bộ phận lắp ráp chỉ là ghép các thành phần để tạo ra chiếc xe mà thôi. Bộ phận lắp ráp chính là một HOF, nó nhận output của ba bộ phận còn lại để tạo ra output cho riêng nó. Có thể diễn giải như thế này: 123456789101112131415161718192021222324class BanhXe&#123;&#125; class KhungXe&#123;&#125; class DongCoXe&#123;&#125; // ham tao banh xe def taoBanhXe() = &#123; val banhXe = new BanhXe banhXe &#125; // ham tao khung xe def taoKhungXe() = &#123; val khungXe = new KhungXe khungXe &#125; // ham tao dong co xe def taoDongCoXe() = &#123; val dongCoXe = new DongCoXe dongCoXe &#125; // HOF function def lapRapXe(taoBanhXe(), taoKhungXe(), taoDongCoXe()) Từ ví dụ trên, chúng ta có thể hiểu tính trừu tượng hóa của HOF giúp che giấu chi tiết bên trong một function, làm giảm sự phức tạp. Vấn đề sẽ được xử lý ở một tầng cao hơn, trừu tượng hơn. Tính tái sử dụng (Reusable)Cũng sử dụng ví dụ về dây chuyền tạo ra một chiếc xe. Chúng ta xây dựng một dây chuyền sản xuất xe máy. Tuy nhiên, nếu phải tạo ra thêm một dây chuyền sản xuất xe hơi thêm vào thì sẽ như thế nào ? Tạo ra một dây chuyền mới là giải pháp đơn giản nhất nhưng lại tốn kém về chi phí. Chúng ta có thể bổ sung thêm cho bộ phận tạo bánh xe máy khả năng tạo ra bánh xe hơi. Tương tự như vậy, bộ phận tao khung xe và động cơ đều trang bị thiết bị tạo ra đồng thời linh kiện cho xe máy lẫn xe hơi. Như vậy, ba bộ phân trên đều được sử dụng tùy theo yêu cầu tạo ra sản phẩm. Đó chính là tính tái sử dụng. Cách sử dụng HOF trong ScalaMột bài toán đơn giản được đặt ra, hãy hình dung bạn đang là một ông chủ và muốn tăng lương cho nhân viên của mình. Tăng lương là việc bạn nhân số lương hiện tại của nhân viên với một hệ số nhất định. Bạn nghĩ rằng, việc tăng lương cần linh động do đó phải tạo ra nhiều cách tăng lương khác nhau. Với bài toán trên, chúng ta sẽ đi giải quyết như sau: Để tiện cho việc quản lý vấn đề tăng lương, bạn sử dụng một Object có tên là SalaryRaiser. Bạn có 3 mức tăng lương khác nhau, theo thứ tự tăng dần là: smallPromotion(), greatPromotion() và hugePromotion(). Ở mức smallPromotion, hệ số là 1.1 Ở mức smallPromotion, hệ số là logarit cơ số 10 của số lương hiện tại ứng với nhân viên đó. Ở mức smallPromotion, hệ số là số lương hiện tại của nhân viên đó. Theo cách thông thường, chúng ta sẽ dùng một vòng for để cập nhật giá trị lương của từng nhân viên. Sau đó, trả về danh sách lương của nhân viên sau khi đã cập nhật. Các bạn xem code phía dưới. 123456789101112131415161718192021222324object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * 1.1 &#125; salaries &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * math.log(salaries(i)) &#125; salaries &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * salaries(i) &#125; salaries &#125;&#125; Với HOF, việc viết code trở nên dễ dàng và ngắn gọn hơn khá nhiều. Ở đây, chúng ta sẽ sử dụng một HOF đó là map(). Chúng ta truyền vào map() một function, chính function này sẽ giúp chúng ta thay đổi lương của mỗi nhân viên theo hệ số mong muốn. Hàm map() đã thể hiện tính linh hoạt thông qua việc định nghĩa cách xử lý từng phần tử trong Array. 123456789101112131415object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * 1.1) &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * math.log(salary)) &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * salary) &#125;&#125; Hiện nay đối với Scala, map() là một trong những HOF được dùng nhiều nhất. Ngoài ra, các bạn có thể tìm hiểu thêm về các HOF khác như filter(), flatMap() … Nguồn tham khảo https://discuss.grokking.org/t/higher-order-functions-la-gi-va-d-c-s-d-ng-nh-th-nao/309 https://docs.scala-lang.org/tour/higher-order-functions.html","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]}]}