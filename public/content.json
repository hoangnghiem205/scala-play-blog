{"meta":{"title":"Scala-Play","subtitle":null,"description":null,"author":"scala-play.com","url":"https://scala-play.com"},"pages":[],"posts":[{"title":"Làm việc với Slick trong Play Framework","slug":"slick","date":"2018-10-30T03:00:00.000Z","updated":"2018-10-30T11:11:40.501Z","comments":true,"path":"2018/10/30/slick/","link":"","permalink":"https://scala-play.com/2018/10/30/slick/","excerpt":"I. ORMORM (Object Relational Mapping) là một kỹ thuật lập trình ánh xạ từ cơ sở dữ liệu sang đối tượng trong các ngôn ngữ lập trình hướng đối tượng như Java,Scala … (các table tương ứng với các class, quan hệ giữa các table tương ứng với quan hệ giữa các class). Sử dụng ORM cho phép người lập trình thao tác với database một cách dễ dàng thông qua các đối tượng mà không cần trực tiếp quan tâm tới database.Một số framework sử dụng kỹ thuật ORM: Play Scala sử dụng Slick, Sping Java sử dụng Hibernate…","text":"I. ORMORM (Object Relational Mapping) là một kỹ thuật lập trình ánh xạ từ cơ sở dữ liệu sang đối tượng trong các ngôn ngữ lập trình hướng đối tượng như Java,Scala … (các table tương ứng với các class, quan hệ giữa các table tương ứng với quan hệ giữa các class). Sử dụng ORM cho phép người lập trình thao tác với database một cách dễ dàng thông qua các đối tượng mà không cần trực tiếp quan tâm tới database.Một số framework sử dụng kỹ thuật ORM: Play Scala sử dụng Slick, Sping Java sử dụng Hibernate… Ưu nhược điểm của ORM:Ưu điểm: Giúp người lập trình tập trung vào hướng đối tượng. Làm việc được với nhiều loại database, nhiều kiểu dữ liệu khác nhau, dễ dàng thay đổi loại database. Các câu lệnh SQL không phụ thuộc vào loại database. Đơn giản, dễ sử dụng: Hỗ trợ HSQL , cung cấp nhiều kiểu API truy vấn. Năng suất hơn: viết code ít hơn, phù hợp với các case Có thể sử dụng lại code. Nhược điểm: Khả năng truy vấn bị hạn chế, nhiều trường hợp ta vẫn phải sử dụng native SQL để truy vấn database. Khó tối ưu câu lệnh SQL (do câu lệnh SQL được ORM tự động sinh ra). II. Truy vấn ORM với slick scala:Với các bảng có mối quan hệ sau: Mối quan hệ của các bảng: student - teacher : N-N student - classes : 1-N teacher - classes : 1-N student - student_teacher : 1-N teacher - student_teacher : 1-N Ta sẽ thực hiện các trường hợp truy vấn và kết quả từ database khác nhau.Trường hợp 1: Xét bảng student:12def searchStudentWhere(id: Int): Future[Seq[Tables.Student]] = db.run(studentTable.filter(_.studentId === id).sortBy(_.studentId).result) Trường hợp 2: Xét bảng classes - student: 1-N1234567def searchStudentClassOrder(): Future[Seq[(Student, Option[Classes])]] = &#123; val action = (for &#123; (a, b) &lt;- studentTable joinLeft classesTable on (_.classId === _.classId) &#125; yield (a, b)).filter(_._1.studentId === id)db.run(action.sortBy(_._1.studentId).result) &#125; Trường hợp 3: Xét bảng student - teacher: N-N với bảng trung gian student_teacher1234567def searchStudentTeacherWhere(id: Int): Future[Seq[(StudentTeacher, Option[Student], Option[Teacher])]] = &#123; val action = (for &#123; ((a, b), c) &lt;- (studentTeacherTable jo inLeft studentTable on (_.studentId === _.studentId)) joinLeft teacherTable on (_._1.teacherId === _.teacherId) &#125; yield (a, b, c)).filter(_._3.map(_.teacherId) === id).sortBy(_._3.map(_.teacherId)) db.run(action.result) &#125; Trường hợp 4: Xét 3 bảng Student - teacher - classes12345678910def searchStudentClassTeacherWhere(id: Int): Future[Seq[(Tables.StudentTeacher, Option[Student], Option[Teacher], Option[Classes])]] = &#123; val action = (for &#123; (((a, b), c), d) &lt;- ((studentTeacherTable joinLeft studentTable on (_.studentId === _.studentId)) joinLeft teacherTable on (_._1.teacherId === _.teacherId)) joinLeft classesTable on (_._2.map(_.classId.getOrElse(0)) === _.classId) &#125; yield (a, b, c, d)).filter(_._4.map(_.classId) === id).sortBy(_._3.map(_.teacherId)) db.run(action.result) &#125; III. Plain SQLĐôi khi bạn cần phải viết trực tiếp mã SQL cho một hoạt động không được hỗ trợ trong ORM, thay vì quay lại JDBC bạn có thể sử dụng SQL Plain. Bạn chỉ cần làm rõ các trường của đối tượng với các trường trong bảng database (thay vì ánh xạ chúng) bằng cách sử dụng thư viện GetResult có sẵn trong slick123456import slick.jdbc.GetResultimplicit val GetStudentResults = GetResult(r =&gt; Student(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;))implicit val GetClassResults = GetResult(r =&gt; Tables.Classes(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;))implicit val GetTeacherResults = GetResult(r =&gt; Teacher(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;))implicit val GetStudentTeacherResults = GetResult(r =&gt; StudentTeacher(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;)) Một số câu truy vấn: Trường hợp 1: Xét bảng student:1234def searchStudentWhereSql(id: Int): Future[Seq[Tables.Student]] = &#123; val action = sql\"select *from student where student_id = $id order by student_id\".as[Student] db.run(action)&#125; Trường hợp 2: Xét bảng classes - student: 1-N1234def searchStudentClassWhereSql(id: Int): Future[Vector[(Student, Classes)]] = &#123; val action = sql\"select *from student a left join classes b on a.class_id = b.class_id where a.student_id = $id order by a.class_id\".as[(Student, Classes)] db.run(action)&#125; Trường hợp 3: Xét bảng student - teacher: N-N với bảng trung gian student_teacher12345678910def searchStudentTeacherWhereSql(id: Int): Future[Vector[(Student, StudentTeacher, Teacher)]] = &#123; val action = sql\"\"\"select * from student a left join student_teacher b on a.student_id = b.student_id left join teacher c on b.teacher_id = c.teacher_id where c.teacher_id = $id order by a.student_id;\"\"\".as[(Student, StudentTeacher, Teacher)] db.run(action)&#125; Trường hợp 4: Xét 3 bảng Student - teacher - classes12345678910def searchStudentClassTeacherWhereSql(id: Int): Future[Vector[(Student, StsudentTeacher, Teacher, Classes)]] = &#123; val action = sql\"\"\"select * from student a left join student_teacher b on a.student_id = b.student_id left join teacher c on b.teacher_id = c.teacher_id left join classes d on c.class_id = d.class_id where a.class_id = $id;\"\"\".as[(Student, StudentTeacher, Teacher, Classes)] db.run(action)&#125; IV. So sánh ORM với Plain SQL - Plain SQL ORM Hiệu năng Nhanh hơn chậm hơn Tối ưu Dễ tối ưu hơn Khó tối ưu hơn Tính năng động Phải thay đổi code khi thay đổi loại database sử dụng Tương thích với nhiều loại database mà ORM hỗ trợ, không cần thay đổi code khi thay đổi loại database Khả năng sử dụng lại code Không Có Nguồn tham khảo:http://slick.lightbend.com/doc/3.0.0/introduction.html Tác giả: Nguyễn Văn Linh","categories":[{"name":"play","slug":"play","permalink":"https://scala-play.com/categories/play/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Twirl template engine trong Play Framework","slug":"twirl-template-engine","date":"2018-10-25T10:00:00.000Z","updated":"2018-10-30T11:05:44.334Z","comments":true,"path":"2018/10/25/twirl-template-engine/","link":"","permalink":"https://scala-play.com/2018/10/25/twirl-template-engine/","excerpt":"Template engine là gì ?Template engine là một bộ xử lí template thường được viết bằng ngôn ngữ back-end . Cho phép xử lí nghiệp vụ logic ở tầng view , giúp luồng code làm việc dễ dàng và linh hoạt hơn Giúp xử lí ,truy xuất , tính toán ,hiển thị hiệu quả dữ liệu ở trong phần giao diện . Ở runtime, template engine thay thế những biến trong template với giá trị thực và chuyển đổi template thành file HTML gửi tới client.","text":"Template engine là gì ?Template engine là một bộ xử lí template thường được viết bằng ngôn ngữ back-end . Cho phép xử lí nghiệp vụ logic ở tầng view , giúp luồng code làm việc dễ dàng và linh hoạt hơn Giúp xử lí ,truy xuất , tính toán ,hiển thị hiệu quả dữ liệu ở trong phần giao diện . Ở runtime, template engine thay thế những biến trong template với giá trị thực và chuyển đổi template thành file HTML gửi tới client. Ví dụ : Javascript thì có một số template engine như Mustache, EJS . PHP thì có Twig, Smarty ,Mustache. Java thì có Apache Velocity,Thymeleaf, Apache FreeMaker,Groovy. Twirl là gì ?Khái niệm: Twirl là 1 bộ xử lí template dựa trên scala đi kèm với Play framework cho phép luồng code dễ dàng , chặt chẽ ,linh hoạt . Ví dụ: Khi bạn cần hiển thị một bảng với số lượng hàng chưa biết trước, sẽ rất vất vả khi mà bạn phải code thuần cả table đó. Thay cho việc đó, chúng ta dùng template engine. Template engine dựng khung table đủ các cột và 1 dòng chỉ định đến dữ liệu tương ứng, dữ liệu sẽ theo từng trường hợp hiện thị phù hợp.123456789101112131415161718&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Class&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @for(student &lt;- students)&#123; &lt;tr&gt; &lt;td&gt;@student.name&lt;/td&gt; &lt;td&gt;@student.className&lt;/td&gt; &lt;td&gt;@student.address&lt;/td&gt; &lt;/tr&gt; &#125; &lt;/tbody&gt; &lt;/table&gt; Tại sao lại chọn twirl ? [Chặt chẽ, biểu cảm , linh hoạt ] : nó giảm thiểu số lượng ký tự và tổ hợp phím được yêu cầu trong một tệp và cho phép luồng công việc mã hóa nhanh, linh hoạt.Không giống như hầu hết các cú pháp mẫu, bạn không cần phải ngắt mã hóa của mình để biểu thị rõ ràng các khối máy chủ trong HTML của bạn. Trình phân tích cú pháp đủ thông minh để suy ra điều này từ mã của bạn. Điều này cho phép một cú pháp thực sự nhỏ gọn và biểu cảm, sạch sẽ, nhanh chóng và thú vị để nhập. [Dễ học] : nó cho phép bạn nhanh chóng trở nên năng suất, với tối thiểu các khái niệm. Bạn chỉ cần sử dụng các cấu trúc Scala đơn giản và tất cả các kỹ năng HTML hiện có của bạn [Không phải là một ngôn ngữ mới] : Cho phép các nhà phát triển Scala sử dụng các kỹ năng ngôn ngữ Scala hiện có và cung cấp cú pháp đánh dấu mẫu cho phép tạo luồng công việc xây dựng HTML tuyệt vời. [Có thể chỉnh sửa trong bất kì trình soạn thảo văn bản nào] :nó không yêu cầu một công cụ cụ thể và cho phép bạn làm việc hiệu quả trong bất kỳ trình soạn thảo văn bản thuần tuý nào. Cú pháp của twirl ?Play scala template đơn giản là 1 file text đơn giản gồm những khối code scala nhỏ.Templates có thể sinh ra bất kì định dạng text nào như là HTML, XML, CSV. Các template được biên dịch thành các hàm Scala chuẩn, theo một quy ước đặt tên đơn giản. Nếu bạn tạo một file template views/Application/index.scala.html , nó sẽ sinh ra một lớp views.html.Application.index gắn với phương thức apply(). Đây là một template đơn giản: 12345678@(teachers: List[Teacher])&lt;h1&gt;Welcome @customer.name!&lt;/h1&gt;&lt;ul&gt; @for(teacher &lt;- teachers) &#123; &lt;li&gt;@teacher.name&lt;/li&gt; &#125;&lt;/ul&gt; Sau đó bạn có thể gọi nó từ bất kỳ mã Scala nào như bạn thường gọi một phương thức trên một lớp: 1val content = views.html.Application.index(teachers); Một scala template là một file HTML với những câu lệnh scala được nhúng vào và bắt đầu bằng kí tự @.Một template cũng là 1 hàm ,nó cần tham số và được khai báo ở dòng đầu tiên của file template. Ví dụ:12@(teachers: List[Teacher])@(title: String = \"Home\") NHỮNG TRƯỜNG HỢP HAY SỬ DỤNGPhép lặp12345&lt;ul&gt;@for(p &lt;- products) &#123; &lt;li&gt;@p.name (@p.price)&lt;/li&gt;&#125;&lt;/ul&gt; Khối if12345@if(items.isEmpty) &#123; &lt;h1&gt;Nothing to display&lt;/h1&gt;&#125; else &#123; &lt;h1&gt;@items.size items!&lt;/h1&gt;&#125; Tạo khối code có thể dùng lại123456789@display(product: Product) = &#123; @product.name (@product.price)&#125;&lt;ul&gt;@for(product &lt;- products) &#123; @display(product)&#125;&lt;/ul&gt; Comment123@********************* This is a comment **********************@ Pattern matching12345678@user match &#123; case Some(name) =&gt; &#123; &lt;span class=”admin”&gt; Connect to (@name) &lt;/span&gt; &#125; case None =&gt; &#123; &lt;span&gt; Not logged &lt;/span&gt; &#125;&#125; Import12@import utils._@import models. LAYOUT[1] Khai báo [views/main.scala.html] hoạt động như một layout template chính:12345678910@(title: String)(content: Html)&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;@title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;section class=\"content\"&gt;@content&lt;/section&gt; &lt;/body&gt;&lt;/html&gt; [2] Như bạn thấy, mẫu này có hai tham số: title và block code HTML. Bây giờ chúng ta có thể tái sử dụng nó từ một template khác [views/Application/index.scala.html]123@main(title = \"Home\") &#123; &lt;h1&gt;Home page&lt;/h1&gt;&#125; Nhận xét về độ tiện lợi của twirlTwirl giúp tiết kiệm thời gian khi viết đi viết lại cấu trúc code phổ biến. Nguồn tham khảo:https://www.playframework.com/documentation/2.5.x/ScalaTemplateshttps://alvinalexander.com/scala/create-play-framework-template-functions-exampleshttps://www.slideshare.net/knoldus/knolx-pte Tác giả: Nguyễn Đình Cường","categories":[{"name":"play","slug":"play","permalink":"https://scala-play.com/categories/play/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Giới thiệu về List trong Scala","slug":"scala-lists","date":"2018-10-16T02:11:35.000Z","updated":"2018-10-30T11:05:34.694Z","comments":true,"path":"2018/10/16/scala-lists/","link":"","permalink":"https://scala-play.com/2018/10/16/scala-lists/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;List trong scala gần tương tự như mảng, vì mọi phần tử đều cùng kiểu dữ liệu nhưng lại có hai sự khác biệt quan trọng: Đầu tiên, List không thể thay đổi, có nghĩa những phần tử trong một List không thể thay đổi được bằng phép gán.","text":"&nbsp;&nbsp;&nbsp;&nbsp;List trong scala gần tương tự như mảng, vì mọi phần tử đều cùng kiểu dữ liệu nhưng lại có hai sự khác biệt quan trọng: Đầu tiên, List không thể thay đổi, có nghĩa những phần tử trong một List không thể thay đổi được bằng phép gán. Thứ hai, List đại diện cho một danh sách liên kết các phần tử, trong khi đó các phần tử của array(mảng) đước xếp cạnh, liên tiếp với nhau. Kiểu của một List được viết duới dạng : List[T]. Bạn hãy xem thử ví dụ dưới đây, một vài List được định nghĩa cho các kiểu dữ liệu khác nhau. 12345678910111213141516// List of Stringsval fruit: List[String] = List(\"apples\", \"oranges\", \"pears\")// List of Integersval nums: List[Int] = List(1, 2, 3, 4)// Empty List.val empty: List[Nothing] = List()// Two dimensional listval dim: List[List[Int]] = List( List(1, 0, 0), List(0, 1, 0), List(0, 0, 1) ) Tất cả List được định nghĩa với hai khối cơ bản là :: và Nil ở cuối. Nil cũng biểu thị một danh sách trống. Tất cả List trên được định nghĩa như sau: 12345678910// List of Stringsval fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil))// List of Integersval nums = 1 :: (2 :: (3 :: (4 :: Nil)))// Empty List.val empty = Nil// Two dimensional listval dim = (1 :: (0 :: (0 :: Nil))) :: (0 :: (1 :: (0 :: Nil))) :: (0 :: (0 :: (1 :: Nil))) :: Nil Vừa rồi là một số giới thiệu sơ lược của mình về List trong Scala. Tiếp sau đây chúng ta sẽ đi tìm hiểu sâu hơn về một số cách thao tác và phương thức sử dụng trong List Thao tác cơ bản với ListTất cả thao tác trên List được thể hiện theo ba phương thức sau đây: No Phương thức và Mô tả 1 head: Phương thức này trả về phần tử đầu tiên của list. 2 tail: Phương thức này trả về 1 danh sách gồm tất cả phần tử ngoại trừ phần tử đầu tiên. 3 isEmpty: Phương thức này trả về true nếu list rỗng, và ngược lại trả về false. Ví dụ sau cho ta thấy cách dùng các phương thức trên. Ví dụ: 12345678910 object Demo &#123; def main(args: Array[String]) &#123; val fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) val nums = Nil println( \"Head of fruit : \" + fruit.head ) println( \"Tail of fruit : \" + fruit.tail ) println( \"Check if fruit is empty : \" + fruit.isEmpty ) println( \"Check if nums is empty : \" + nums.isEmpty ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1234Head of fruit : applesTail of fruit : List(oranges, pears)Check if fruit is empty : falseCheck if nums is empty : true Ghép nối các ListBạn có thể dùng hoặc phép toán ::: hoặc phương thức List.:::() hoặc List.concat() để thêm hai hoặc nhiều List trở lên. Vui lòng khám phá ví dụ dưới đây Ví dụ123456789101112131415object Demo &#123; def main(args: Array[String]) &#123; val fruit1 = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) val fruit2 = \"mangoes\" :: (\"banana\" :: Nil) // dùng 2 hay nhiều list với toán tử ::: var fruit = fruit1 ::: fruit2 println( \"fruit1 ::: fruit2 : \" + fruit ) // dùng 2 list với phương thức Set.:::() fruit = fruit1.:::(fruit2) println( \"fruit1.:::(fruit2) : \" + fruit ) // truyền hai hay nhiều list làm tham số fruit = List.concat(fruit1, fruit2) println( \"List.concat(fruit1, fruit2) : \" + fruit ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Những lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả123fruit1 ::: fruit2 : List(apples, oranges, pears, mangoes, banana)fruit1.:::(fruit2) : List(mangoes, banana, apples, oranges, pears)List.concat(fruit1, fruit2) : List(apples, oranges, pears, mangoes, banana) Tạo List đồng nhấtBạn có thể dùng phương thức List.fill() để tạo một 0 hoặc nhiều bản sao của các phần tử . Hãy thử chương trình ví dụ sau đây. Ví dụ:123456789object Demo &#123; def main(args: Array[String]) &#123; val fruit = List.fill(3)(\"apples\") // Repeats apples three times. println( \"fruit : \" + fruit ) val num = List.fill(10)(2) // Repeats 2, 10 times. println( \"num : \" + num ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:12fruit : List(apples, apples, apples)num : List(2, 2, 2, 2, 2, 2, 2, 2, 2, 2) Tạo bảng một hàmBạn có thể dùng một hàm cùng với phương thức List.tabulate() để tác dụng lên tất cả phần tử của List trước khi tạo bảng List. Tham số của hàm này giống như phương thức List.fill: Tham số thứ nhất cho biết kích thước List cần tạo, và tham số thứ hai mô tả các phần tử của List. Sự khác biệt duy nhất là thay vì phần tử cố định , chúng được tính từ một hàm. Thử chương trình ví dụ sau đây Ví dụ:123456789object Demo &#123; def main(args: Array[String]) &#123; // Creates 5 elements using the given function. val squares = List.tabulate(6)(n =&gt; n * n) println( \"squares : \" + squares ) val mul = List.tabulate( 4,5 )( _ * _ ) println( \"mul : \" + mul ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả123squares : List(0, 1, 4, 9, 16, 25)mul : List(List(0, 0, 0, 0, 0), List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8), List(0, 3, 6, 9, 12)) Đảo ngược thứ tự phần tử trong ListBạn có thể dùng phương thức List.reverse để đảo ngược tất cả phần tử trong danh sách. Ví dụ sau đây cho thấy cách dùng nó. Ví dụ:1234567object Demo &#123; def main(args: Array[String]) &#123; val fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) println( \"Before reverse fruit : \" + fruit ) println( \"After reverse fruit : \" + fruit.reverse ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:12Before reverse fruit : List(apples, oranges, pears)After reverse fruit : List(pears, oranges, apples) Các phương thức của List trong scalaSau đây là những phương thức quan trọng khi bạn dùng khi thao tác với các List. Đối với một danh sách hoàn chỉnh các phương thức có sẵn, hãy kiểm tra tài liệu chính thức của Scala. Sr.No Phương thức và mô tả 1 scala def +(elem: A): List[A] Thêm một phần tử vào đầu list 2 def :::(prefix: List[A]): List[A] Thêm những phần tử của list được truyền, vào trước list ban đầu 3 def ::(x: A): List[A] Thêm một phần tử x vào đầu của list 4 def addString(b: StringBuilder): StringBuilder Gán tất cả phần tử của list vào chuỗi StringBuilder 5 def addString(b: StringBuilder, sep: String): StringBuilder Gán tất cả phần tử của list vào chuỗi StringBuilder b và ngăn cách lần lượt bởi chuỗi sep 6 def apply(n: Int): A Chỉ định và trả về một phần tử bởi chỉ số của nó trong list 7 def contains(elem: Any): Boolean Kiểm tra giá trị được truyền có là một phần tử trong list không. 8 def copyToArray(xs: Array[A], start: Int, len: Int): Unit Sao chép tất cả phần tử của list sang 1 mảng. Tham số cần truyền thêm là vị trí bắt đầu được sao chép sang trong mảng, và độ dài của list. 9 def distinct: List[A] Trả về một list mới từ list đã cho mà không chứa bất kỳ phần tử trùng nào. 10 def drop(n: Int): List[A] Trả về list chứa tất cả phần tử ngoại trừ n phần tử đầu tiên. 11 def dropRight(n: Int): List[A] Trả về list chứa tất cả phần tử ngoại trừ n phần tử cuối cùng. 12 def endsWith[B](that: Seq[B]): Boolean Kiểm tra list có kết thúc với danh sách Seq[] truyền vào hay không. 13 def equals(that: Any): Boolean Phương thức tương tự với các danh sách tùy ý. So sánh danh sách này với một số đối tượng khác. 14 def filter(p: (A) =&gt; Boolean): List[A] Trả về tất cả phần tử trong list thỏa mãn vị từ. 15 def foreach(f: (A) =&gt; Unit): Unit Áp dụng hàm f cho tất cả các phần tử của list. 16 def head: A Chỉ định phần tử đầu tử đầu tiên của list. 17 def indexOf(elem: A, from: Int): Int Tìm vị trí xuất hiện đầu tiên của giá trị A trong list ,kể từ vị trí from trở đi. 18 def init: List[A] Trả về list chứa tất cả phần tử ngoại trừ phần tử cuối cùng. 19 def isEmpty: Boolean Kiểm tra xem list có rỗng không 20 def iterator: Iterator[A] Tạo một trình lặp mới trên tất cả phần tử có trong đối tượng iterable có thể lặp 21 def last: A Trả về phần tử cuối cùng 22 def lastIndexOf(elem: A, end: Int): Int Tìm vị trí xuất hiện cuối cùng của một số giá trị trong list ,trước hoặc tại vị trí end . 23 def length: Int Trả về độ dài của list. 24 def map[B](f: (A) =&gt; B): List[B] Trả về một list mới bằng việc áp dụng hàm f cho tất cả phần tử của list. 25 def max: A Tìm phần tử lớn nhất. 26 def min: A Tìm phần tử nhỏ nhất. 27 def mkString: String Hiển thị ra tất cả phần tử của list dưới dạng một chuỗi. 28 def mkString(sep: String): String Hiển thị ra tất cả phần tử của list trong một chuỗi dùng 1 chuỗi ngăn cách sep 29 def reverse: List[A] Trả về một list mới với các phần tử được đảo ngược. 30 def sorted[B &gt;: A]: List[A Sắp xếp list theo một thứ tự. 31 def startsWith[B](that: Seq[B], offset: Int): Boolean Kiểm tra xem list có chứa danh sách truyền vào tại một vị trí offset không. 32 def sum: A Tính tổng tất cả phần tử của tập hợp. 33 def tail: List[A] Trả về tất cả phần tử ngoại trừ phần tử đầu tiên. 34 def take(n: Int): List[A] Trả về n phần tử đầu tiên. 35 def takeRight(n: Int): List[A] Trả về n phần tử cuối cùng. 36 def toArray: Array[A] Ép kiểu list sang kiểu mảng array. 37 def toBuffer[B &gt;: A]: Buffer[B] Ép kiểu list sang một bộ đệm có thể thay đổi. 38 def toMap[T, U]: Map[T, U] Chuyển đổi list sang một map 39 def toSeq: Seq[A] Chuyển đổi list sang một danh sách sequence. 40 def toSet[B &gt;: A]: Set[B] Chuyển đổi list sang một Set. 41 def toString(): String Chuyển đổi list sang một chuỗi. Nguồn tham khảohttps://www.tutorialspoint.com/scala/scala_lists.htm Biên dịch: Nguyễn Đình Cường","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Giới thiệu về Option trong Scala","slug":"scala-options","date":"2018-10-15T10:07:20.000Z","updated":"2018-10-30T11:05:24.638Z","comments":true,"path":"2018/10/15/scala-options/","link":"","permalink":"https://scala-play.com/2018/10/15/scala-options/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;Option[T] là một vùng chứa 0 hoặc một phần tử của một kiểu đã cho. Một Option[T] có thể là đối tượng Some[ T ] hoặc None, biểu thị giá trị bị thiếu. Ví dụ, phương thức get của Map trong Scala tạo ra Some (value) nếu một giá trị tương ứng với một khóa đã cho đã được tìm thấy, hoặc None nếu khóa đã cho không được định nghĩa trong Map.","text":"&nbsp;&nbsp;&nbsp;&nbsp;Option[T] là một vùng chứa 0 hoặc một phần tử của một kiểu đã cho. Một Option[T] có thể là đối tượng Some[ T ] hoặc None, biểu thị giá trị bị thiếu. Ví dụ, phương thức get của Map trong Scala tạo ra Some (value) nếu một giá trị tương ứng với một khóa đã cho đã được tìm thấy, hoặc None nếu khóa đã cho không được định nghĩa trong Map. Kiểu Option được dùng thường xuyên trong chương trình scala và bạn có thể so sánh nó với giá trị null có sẵn trong Java để chỉ không có giá trị. Ví dụ , phương thức get trong java.util.HashMap trả về giá trị được lưu trong HashMap ,hoặc null nếu giá trị không được tìm thấy. Giả sử chúng ta có một phương thức lấy một bản ghi từ cơ sở dữ liệu dựa trên khóa chính. 1def findPerson(key: Int): Option[Person] Phương thức này sẽ trả về Some[Person] nếu bản ghi được tìm thấy hoặc None nếu bản ghi không được tìm thấy. Chúng ta cùng theo dõi chương trình sau đây. Ví dụ1234567object Demo &#123; def main(args: Array[String]) &#123; val capitals = Map(\"France\" -&gt; \"Paris\", \"Japan\" -&gt; \"Tokyo\") println(\"capitals.get( \\\"France\\\" ) : \" + capitals.get( \"France\" )) println(\"capitals.get( \\\"India\\\" ) : \" + capitals.get( \"India\" )) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12capitals.get( &quot;France&quot; ) : Some(Paris)capitals.get( &quot;India&quot; ) : None Cách phổ biến nhất để lấy các giá trị tùy ý sang một bên là thông qua a pattern match. Ví dụ, hãy thử chương trình sau. Ví dụ1234567891011object Demo &#123; def main(args: Array[String]) &#123; val capitals = Map(\"France\" -&gt; \"Paris\", \"Japan\" -&gt; \"Tokyo\") println(\"show(capitals.get( \\\"Japan\\\")) : \" + show(capitals.get( \"Japan\")) ) println(\"show(capitals.get( \\\"India\\\")) : \" + show(capitals.get( \"India\")) ) &#125; def show(x: Option[String]) = x match &#123; case Some(s) =&gt; s case None =&gt; \"?\" &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12show(capitals.get( &quot;Japan&quot;)) : Tokyoshow(capitals.get( &quot;India&quot;)) : ? Qua phần trên, mình đã giới thiệu qua và các bạn đã phần nào hiểu được sơ lược về cách sử dụng Option trong scala. Bây giờ chúng ta hãy cùng đi tìm hiểu sâu hơn về các phương thức thường xuyên được sử dụng trong Option. Dùng phương thức getOrElse() &nbsp;&nbsp;&nbsp;&nbsp; Sau đây là chương trình ví dụ để chỉ cách sử dụng phương thức getOrElse () để truy cập một giá trị hoặc một giá trị mặc định khi không có giá trị nào. Ví dụ12345678object Demo &#123; def main(args: Array[String]) &#123; val a:Option[Int] = Some(5) val b:Option[Int] = None println(\"a.getOrElse(0): \" + a.getOrElse(0) ) println(\"b.getOrElse(10): \" + b.getOrElse(10) ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12a.getOrElse(0): 5b.getOrElse(10): 10 Dùng phương thức isEmpty() &nbsp;&nbsp;&nbsp;&nbsp; Sau dây là chương trình ví dụ để chỉ cách dùng phương thức isEmpty() để kiểm tra Option là None hay không Ví dụ12345678object Demo &#123; def main(args: Array[String]) &#123; val a:Option[Int] = Some(5) val b:Option[Int] = None println(\"a.isEmpty: \" + a.isEmpty ) println(\"b.isEmpty: \" + b.isEmpty ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12a.isEmpty: falseb.isEmpty: true Những phương thức Option trong Scala &nbsp;&nbsp;&nbsp;&nbsp; Sau đây là các phương thức quan trọng mà bạn có thể sử dụng khi lựa chọn Options. Để biết danh sách đầy đủ các phương pháp có sẵn, vui lòng kiểm tra tài liệu chính thức của Scala. Sr.No Phương thức và mô tả 1 def get: A Trả về giá trị của option 2 def isEmpty: Boolean Trả về true nếu option là None, ngược lại thì false 3 def productArity: Int Kích thước của kết quả này. Đối với một kết quả A(x_1, …, x_k) trả về k. 4 def productElement(n: Int): Any Phần tử thứ n của kết quả này , dựa trên 0. Nói cách khác, đối với một kết quả A(x_1, …, x_k), trả về x_(n + 1) trong đó 0 &lt; n &lt; k. 5 def exists(p: (A) =&gt; Boolean): Boolean Trả về true nếu option này khác rỗng và hàm p trả về true khi áp dụng cho giá trị của Option này. Nếu không, trả về false. 6 def filter(p: (A) =&gt; Boolean): Option[A] Trả về Option này nếu nó khác rỗng, và áp dụng hàm p cho giá trị của Option này trả về true. Nếu không, trả về None. 7 def filterNot(p: (A) =&gt; Boolean): Option[A] Trả về Option này nếu nó khác rỗng, và áp dụng hàm p cho giá trị của Option này trả về false. Nếu không, trả về None. 8 def flatMapB =&gt; Option[B]): Option[B] Trả về kết quả của áp dụng hàm f cho giá trị của Option nếu Option này khác rỗng. Trả về None nếu Option này rỗng. 9 def foreachU =&gt; U): Unit Áp dụng hàm f cho giá trị của option ,nếu nó khác rỗng. Ngược lại, không làm gì cả 10 def getOrElseB &gt;: A: B Trả về giá trị của option nếu option này khác rỗng, ngược lại trả về kết quả của đánh giá default mặc định. 11 def isDefined: Boolean Trả về true nếu option này là một thể hiện của kiểu Some , ngược lại false. 12 def iterator: Iterator[A] Trả về một trình lặp singleton trả về giá trị của Option nếu nó khác rỗng, hoặc một trình lặp rỗng nếu option rỗng. 13 def mapB =&gt; B): Option[B] Trả về một Some chứa kết quả của áp dụng hàm f cho giá trị của Option này nếu Option này khác rỗng. Nếu không, trả về None. 14 def orElseB &gt;: A: Option[B] Trả về Option này nếu nó khác rỗng , không thì trả về kết quả của đánh giá thay thế alternative. 15 def orNull Trả về giá trị của option nếu nó khác rỗng, hoặc trả về null nếu nó rỗng. Nguồn tham khảohttps://www.tutorialspoint.com/scala/scala_options.htm Biên dịch: Nguyễn Đình Cường","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Tích hợp Gitlab-CICD vào dự án thực tế","slug":"intergrated-cicd","date":"2018-10-11T07:27:20.000Z","updated":"2018-10-30T11:05:11.698Z","comments":true,"path":"2018/10/11/intergrated-cicd/","link":"","permalink":"https://scala-play.com/2018/10/11/intergrated-cicd/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;Gần đây, team Best Solution đã tích hợp được Gitlab-CICD vào dự án Green-Blue để tự động hóa quá trình Build, Deploy ứng dụng lên Staging. Dưới đây là hướng dẫn về cách tích hợp Gitlab-CICD cho những dự án khác. Trong hướng dẫn này, mình sử dụng GitLab Community Edition 8.16.3 và Gitlab Runner 1.11.1","text":"&nbsp;&nbsp;&nbsp;&nbsp;Gần đây, team Best Solution đã tích hợp được Gitlab-CICD vào dự án Green-Blue để tự động hóa quá trình Build, Deploy ứng dụng lên Staging. Dưới đây là hướng dẫn về cách tích hợp Gitlab-CICD cho những dự án khác. Trong hướng dẫn này, mình sử dụng GitLab Community Edition 8.16.3 và Gitlab Runner 1.11.1 1. Tích hợp Gitlab Runner và thêm biến môi trường cho dự án trên Gitlab&nbsp;&nbsp;&nbsp;&nbsp;Để có thể tiến hành quá trình Build-Deploy, Gitlab sử dụng một server có tên là Runner. Tại đây, ứng dụng của chúng ta sẽ được Build,Test, sau đó được Deploy lên server. &nbsp;&nbsp;&nbsp;&nbsp;Hiện tại, Gitlab cung cấp các Shared Runner miễn phí cho chúng ta. Nhưng vì yếu tố bảo mật và đảm bảo hiệu năng, chúng ta nên tự cài đặt một Runner Server riêng phục vụ cho các dự án của công ty. &nbsp;&nbsp;&nbsp;&nbsp;Trong team Best Solution, mình đã cài đặt một Runner Server có tên là the runner. Chúng ta chỉ cần tích hợp Runner vào dự án là có thể sử dụng được. 1.1 Tích hợp Gitlab RunnerChúng ta vào mục Runner (1) của dự án, sẽ thấy màn hình như hình phía dưới. &nbsp;&nbsp;&nbsp;&nbsp;Ở đây có hai phần, Specific Runners và Shared Runners. Như đã nói ở trên, chúng ta chỉ quan tâm tới Specific Runners. Nhìn vào (2), các bạn sẽ thấy một Runner mà mình đã cài đặt sẵn. Để tích hợp Runner vào dự án, chỉ cần nhấn vào nút Enable for this project như (3) là xong. 1.2 Thêm biến môi trường cho dự ánĐể thêm biến môi trường, chúng ta vào mục Variables (1). &nbsp;&nbsp;&nbsp;&nbsp;Đây chính là nơi các bạn khai báo biến môi trường với Gitlab và Runner sẽ sử dụng những biến môi trường này. Có một câu hỏi là: tại sao lại cần biến môi trường ?&nbsp;&nbsp;&nbsp;&nbsp;Mình sẽ lấy ví dụ để trả lời câu hỏi này, các bạn nhìn vào (3). Ở đây mình khai báo một biến môi trường với tên là SSH_PRIVATE_KEY và giá trị của nó sẽ là tất cả các ký tự trong file key mà các bạn sử dụng để ssh lên server khi tiến hành Deploy ứng dụng. Nếu chúng ta không khai báo một key ở đây, thì Runner Server sẽ không thể tiến hành quá trình Deploy được.&nbsp;&nbsp;&nbsp;&nbsp;Với một dự án mới, sẽ không có biến môi trường nào hiển thị ở đây cả. Các bạn sẽ phải tự thêm vào. Đối với team Best Solution, chỉ cần thêm biến SSH_PRIVATE_KEY là đủ. 2. Viết script triển khai ứng dụng lên server&nbsp;&nbsp;&nbsp;&nbsp;Trên server, chúng ta tạo một thư mục để triển khai ứng dụng. Ở đây, mình lấy ví dụ với ứng dụng Gree-Blue, thư mục sẽ giống như hình bên dưới:green-blue-cicd/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ config/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ database.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ log/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ application.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ script/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ deploy.sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ source/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ green-blue-STAGING-20181005172440/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ version/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ green-blue-STAGING-20181005172440.zip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ … Mình sẽ giới thiệu qua mục đích của từng folder trong thư mục chính green-blue-cicd/. Đầu tiên là folder config/, đây là nơi chứa config của ứng dụng. Hiện tại, mình chỉ để config của database trong đó. Chúng ta cần một file config database mẫu để dùng cho quá trình triển khai ứng dụng. Thứ hai là folder log/, đây là nơi chứa log của ứng dụng trong quá trình chạy. Thứ ba là folder script/, mình để script triển khai ứng dụng ở đây. Folder source/ là nơi chứa mã nguồn được giải nén ra từ các phiên bản của ứng dụng nằm bên trong folder version/. Điều quan tâm nhất là script deploy.sh sẽ được viết như thế nào …123456789101112131415161718192021#!/bin/bash# define app nameAPP_NAME=\"green-blue\"# unzip source-codecd /root/web/green-blue-cicd/versionunzip $1.zip -d ../source/# re-config applicationcd /root/web/green-blue-cicd/source/$1/confmv mailer.conf.example mailer.confmv silhouette.conf.example silhouette.confcp /root/web/green-blue-cicd/config/database.conf ./# kill process of prev-versionpid=$(ps -p $(lsof -ti tcp:9000) o pid=)kill -9 $pid# run server &amp; write log filecd /root/web/green-blue-cicd/source/$1/bin/nohup ./$APP_NAME -Dplay.http.secret.key=123123123 -Dplay.evolutions.db.default.autoApply=true -Dhttp.port=9000 &gt; /root/web/green-blue-cicd/log/application.log &amp; &nbsp;&nbsp;&nbsp;&nbsp;Hình ảnh phía trên là nội dung file deploy.sh dùng để triển khai Green-Blue. Trong đó, $1 là tham số truyền vào khi chạy script deploy.sh, ở đây $1 đại diện cho tên của version muốn triển khai. Chúng ta có thể thấy, nội dung file gồm 4 phần:- (1) Giải nén source-code- (2) Cấu hình cho ứng dụng, trong đó có bước lấy file database.conf từ file mẫu ban đầu.- (3) Bỏ bản triển khai trước đó, nó đang chạy ở cổng 9000- (4) Triển khai một version mới và ghi log vào application.log &nbsp;&nbsp;&nbsp;&nbsp;Để triển khai CICD cho một dự án khác, các bạn chỉ cần giữ nguyên cấu trúc thư mục và thay đổi nội dung các file bên trong của nó. Chính xác là chỉ cần thay đổi nội dung file database.conf và file deploy.sh. Nội dung file database.conf sẽ được thay đổi tùy vào các dự án khác nhau. Đối với deploy.sh, chúng ta cần làm 2 việc:- Thay tên của các đường dẫn- Thay tên của ứng dụng trong bước (4). 3. Viết file .gitlab.yml&nbsp;&nbsp;&nbsp;&nbsp;Đầu tiên, chúng ta sẽ đi xem .gitlab-ci.yml của dự án Green-Blue ở đây.Chúng ta sẽ thấy có các phần chính sau: image: docker image được dùng cho quá trình Build - Deploy stages: nơi liệt kê các quá trình được thực thi variables: nơi khai báo các biến môi trường cache: nơi khai báo các thư mục mà bạn muốn cache lại sau mỗi lần Build - Deploy staging: quá trình triển khai ứng dụng lên STAGING &nbsp;&nbsp;&nbsp;&nbsp;Khi viết .gitlab-ci.yml cho một dự án mới, chúng ta chỉ cần quan tâm tới staging, đây là nơi thực thi các câu lệnh tiến hành quá trình Build - Deploy ứng dụng. Các câu lệnh thực thi được chia làm hai phần: a) before_script: các câu lệnh chuẩn bị cho quá trình Deploy, bao gồm các bước:(1) Tạo tên version mới cho ứng dụng12345678# Create VERSION_NAME## Set TIME ZONE- TZ=Asia/Ho_Chi_Minh- ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone## Set VERSION_NAME- export VERSION_NAME=$(date +'%Y%m%d%H%M%S')- echo \"VERSION_NAME is green-blue-STAGING-$&#123;VERSION_NAME&#125;\"- apt-get update -y (2) Cài đặt sbt12345# Install SBT- echo \"deb http://dl.bintray.com/sbt/debian /\" | tee -a /etc/apt/sources.list.d/sbt.list- apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 642AC823- apt-get update -y- apt-get install sbt -y (3) Thay đổi tên version cho ứng dụng123# Change BUILD VERSION- sed -i 's/BUILD_VERSION/'\"STAGING-$&#123;VERSION_NAME&#125;\"'/g' build.sbt- sed -i 's/BUILD_VERSION/'\"green-blue-STAGING-$&#123;VERSION_NAME&#125;\"'/g' public/javascripts/zxcvbnShim.js (4) Thực hiện quá trình Build1- sbt dist (5) Cài đặt ssh12345678# Setup SSH- 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )'# Run ssh-agent (inside the build environment)- eval $(ssh-agent -s)# Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store- ssh-add &lt;(echo \"$SSH_PRIVATE_KEY\")- mkdir -p ~/.ssh- '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' (6) Chuyển mã nguồn sau khi Build lên Staging server12# Send FILE to remote server- scp target/universal/green-blue-STAGING-$&#123;VERSION_NAME&#125;.zip root@133.18.199.250:/root/web/green-blue-cicd/version b) script: các câu lệnh của quá trình Deploy, đây là việc ssh lên Staging và thực thi deploy.sh123- echo \"DEPLOY to STAGING server ...\"# Deploy- ssh root@133.18.199.250 \"sh /root/web/green-blue-cicd/script/deploy.sh green-blue-STAGING-$&#123;VERSION_NAME&#125;\" Chúng ta sẽ phải thay đổi một chút trong khi viết file .gitlab-ci.yml mới.Đối với before_script, chúng ta chỉ cần thay đổi ở các bước (3) và (6): Với bước (3) Thay đổi version := “1.x.x” trong build.sbt thành version := “BUILD_VERSION” Thêm câu lệnh console.log(“Current version is “ + “BUILD_VERSION”) vào đầu file zxcvbnShim.js Với bước (6) thay đổi cái tên green-blue trong đường dẫn target/universal/green-blue-STAGING-${VERSION_NAME}.zip thành tên dự án của bạn. thay đổi đường dẫn /root/web/green-blue-cicd/version cho đúng với đường dẫn với thư mục version/ trên server của bạn. Đối với script: Thay đổi đường dẫn /root/web/green-blue-cicd/script/deploy.sh cho đúng với đường dẫn tới file deploy.sh của bạn trên server. Thay đổi tên green-blue trong green-blue-STAGING-${VERSION_NAME} thành tên dự án của bạn. &nbsp;&nbsp;&nbsp;&nbsp;Đến đây, chúng ta chỉ việc push những gì vừa làm lên branch dev là hoàn thành xong việc tích hợp Gitlab-CICD cho dự án mới. Tác giả: Cao Văn Long","categories":[{"name":"ci/cd","slug":"ci-cd","permalink":"https://scala-play.com/categories/ci-cd/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://scala-play.com/tags/tutorial/"}]},{"title":"Giới thiệu về Tuples trong Scala","slug":"scala-tuples","date":"2018-10-08T10:37:14.000Z","updated":"2018-10-30T11:05:29.246Z","comments":true,"path":"2018/10/08/scala-tuples/","link":"","permalink":"https://scala-play.com/2018/10/08/scala-tuples/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp; Trong Scala, Tuple dùng để gộp một số lượng phần tử cố định cùng với nhau. Không như array (mảng) và list (danh sách), một tuple có thể chứa object (đối tượng) với các kiểu dữ liệu khác nhau và chúng không thay đổi được giá trị. Sau đây là ví dụ về tuple lưu kiểu nguyên và kiểu chuỗi. Đây là một cách khai báo ngắn gọn: 1val t = (1, \"hello\")","text":"&nbsp;&nbsp;&nbsp;&nbsp; Trong Scala, Tuple dùng để gộp một số lượng phần tử cố định cùng với nhau. Không như array (mảng) và list (danh sách), một tuple có thể chứa object (đối tượng) với các kiểu dữ liệu khác nhau và chúng không thay đổi được giá trị. Sau đây là ví dụ về tuple lưu kiểu nguyên và kiểu chuỗi. Đây là một cách khai báo ngắn gọn: 1val t = (1, \"hello\") Cách khai báo cụ thể sẽ giống như sau:1val t = new Tuple2(1, \"hello\") Kiểu thực sự của tuple phụ thuộc vào số lượng và các phần tử và kiểu của các phần tử đó.Do đó kiểu của (99, “Luftballons”) là Tuple2[Int, String]. Kiểu của (‘u’, ‘r’, “the”, 1, 4, “me”) là Tuple6[Char, Char, String, Int, Int, String]. Tuples có kiểu Tuple1 ,Tuple2, Tuple3… .Hiện tại tuples có thể chứa tối đa 22 phần tử ,nếu muốn nhiều hơn ,bạn có thể sử dụng Collection khác ngoài tuple. Đối với mỗi kiểu TupleN , trong đó 1&lt;= N &lt;= 22 Scala định nghĩa một số phương thức truy cập phần tử với đinh nghĩa sau- 1val t = (4,3,2,1) Để truy cập các phần tử của tuple t, bạn có thể dùng phương thức t._1 để truy cập phần tử đầu tiên , t._2 để truy cập phần tử thứ hai, và tương tự . Ví dụ, biểu thức sau đây tính tổng các phần tử của tuple t. 1val sum = t._1 + t._2 + t._3 + t._4 Bạn có thể dùng Tuple để viết một phương thức lấy kiểu List[Double] làm tham số và trả về biến biến count , biến tổng sum , và tổng bình phương ,được trả về dưới kiểu Tuple 3 phần tử , kiểu Tuple3[Int, Double, Double] .Chúng cũng hữu ích khi truyền danh sách các giá trị dữ liệu dưới dạng thông điệp giữa các tác nhân trong lập trình đồng thời. Thử chương trình ví dụ sau: Ví dụ:1234567object Demo &#123; def main(args: Array[String]) &#123; val t = (4,3,2,1) val sum = t._1 + t._2 + t._3 + t._4 println( \"Sum of elements: \" + sum ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:1Sum of elements: 10 Phần trên là những giới thiệu qua của mình về Tuple trong Scala. Bây giờ chúng ta sẽ đi tìm hiểu một vài phương thức thường xuyên được sử dụng trong Tuple. Phép lặp trên Tuple Bạn có thể dùng phương thức Tuple.productIterator() để lặp qua hết tất cả các phần tử của Tuple.Thử ví dụ sau để thực hiện phép lặp trên tuples. Ví dụ:123456object Demo &#123; def main(args: Array[String]) &#123; val t = (4,3,2,1) t.productIterator.foreach&#123; i =&gt;println(\"Value = \" + i )&#125; &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1234Value = 4Value = 3Value = 2Value = 1 Chuyển đổi thành chuỗi Bạn có thể sử dụng phương thức Tuple.toString () để nối tất cả các phần tử của tuple sang kiểu chuỗi. Hãy thử chương trình ví dụ sau để chuyển đổi thành Chuỗi. Ví dụ12345object Demo &#123; def main(args: Array[String]) &#123; val t = new Tuple3(1, \"hello\", Console) println(\"Concatenated String: \" + t.toString() )&#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1Concatenated String: (1,hello,scala.Console$@281acd47) Đảo các phần tử trong TupleBạn có thể sử dụng phương thức Tuple.swap để hoán đổi các phần tử của Tuple2.Hãy thử chương trình ví dụ sau để hoán đổi các phần tử. Ví dụ123456object Demo &#123; def main(args: Array[String]) &#123; val t = new Tuple2(\"Scala\", \"hello\") println(\"Swapped Tuple: \" + t.swap ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1Swapped tuple: (hello,Scala) Nguồn tham khảohttps://www.tutorialspoint.com/scala/scala_tuples.htm Biên dịch: Nguyễn Đình Cường","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Sử dụng Gitlab-CI/CD cơ bản","slug":"git-lab","date":"2018-10-06T03:48:07.000Z","updated":"2018-10-30T11:05:16.250Z","comments":true,"path":"2018/10/06/git-lab/","link":"","permalink":"https://scala-play.com/2018/10/06/git-lab/","excerpt":"1. Các chức năng chính Tự động Build và Deploy lên Staging (đã sử dụng được) Tự động Build và Deploy lên Production (đang phát triển) - Chức năng tự động Build và Deploy lên Staging sẽ được kích hoạt khi merge code vàobranch “dev” hoặc push code lên branch “dev”.","text":"1. Các chức năng chính Tự động Build và Deploy lên Staging (đã sử dụng được) Tự động Build và Deploy lên Production (đang phát triển) - Chức năng tự động Build và Deploy lên Staging sẽ được kích hoạt khi merge code vàobranch “dev” hoặc push code lên branch “dev”. - Chức năng tự động Build và Deploy lên Production sẽ được kích hoạt khi merge code vàobranch “master” hoặc push code lên branch “master”. 2. Cách sử dụngBước 1: merge code vào branch “dev” hoặc push code lên branch “dev” Bước 2: chờ quá trình Build - Deploy diễn raBước 2.1: Đầu tiên, chúng ta vào mục “Pipelines” để kiểm tra trạng thái của quá trình. Bước 2.2: Nhấn vào “running” để đi tới màn hình chi tiết của quá trình. Bước 2.3: ​ Nhấn vào “staging” để đi tới màn hình console - nơi hiển thị chi tiết quá trình build và deploy dự án lên Staging. - Sau bước này, chúng ta sẽ có kết quả của quá trình Build -&gt; Deploy. Sẽ có hai trường hợp xảy ra: Quá trình xảy ra lỗi: Gitlab-CI/CD sẽ báo trạng thái của quá trình sẽ hiển thị giống như . Hoặc hiển thị “ERROR: Job failed: exit code 1” trên màn hình console ở dòng cuối cùng. Quá trình diễn ra thành công: trạng thái sẽ là . Bước 3: xử lý kết quả của quá trình Build - Deploy Bước 3.1: N​ếu kết quả trả về là thành công . Chúng ta sẽ lên Staging server để xemkết quả, công việc triển khai coi như xong. Ngoài ra, chúng ta có thể xem chi tiết hơn bằngcách: - Vào mục “Builds” để xem tất cả các quá trình Build - Deploy đã thực hiện (bao gồm cả quátrình thực thi lại một lần Build - Deploy nào đó) - Vào mục “Environments” để xem các môi trường đã triển khai. Ở đây, chúng ta mới triểnkhai lên môi trường Staging. Môi trường Production sẽ được triển khai sau… Bước 3.2: Nếu kết quả trả lỗi, chúng ta nên đọc lại phần thông tin hiển thi ở màn hình console trước để tìm ra nguyên nhân. Sau đó đi tới mục “related-code” để xem chi tiết đoạn code nào đã gây lỗi cho hệ thống. Tác giả: Cao Văn Long","categories":[{"name":"ci/cd","slug":"ci-cd","permalink":"https://scala-play.com/categories/ci-cd/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://scala-play.com/tags/tutorial/"}]},{"title":"Higher Order Functions trong Scala","slug":"HOF-in-scala","date":"2018-10-02T13:08:24.000Z","updated":"2018-10-30T11:05:39.670Z","comments":true,"path":"2018/10/02/HOF-in-scala/","link":"","permalink":"https://scala-play.com/2018/10/02/HOF-in-scala/","excerpt":"Định nghĩa Higher Order FunctionHigher Order Function là function thỏa mãn ít nhất một trong hai điều kiện : Có ít nhất một tham số truyền vào là một function khác Kết quả trả về của HOF đó là một function khác. Với Higher Order Function, tính trừu tượng hóa, tái sử dụng chính là điểm mạnh.","text":"Định nghĩa Higher Order FunctionHigher Order Function là function thỏa mãn ít nhất một trong hai điều kiện : Có ít nhất một tham số truyền vào là một function khác Kết quả trả về của HOF đó là một function khác. Với Higher Order Function, tính trừu tượng hóa, tái sử dụng chính là điểm mạnh. Tính trừu tượng hóa (Abstraction)Hãy nghĩ đến dây chuyền lắp ráp một chiếc xe. Dây chuyền gồm bốn bộ phận: Bộ phận tạo bánh xe Bộ phận tạo khung xe Bộ phận tạo động cơ Bộ phận lắp ráp Bộ phận tạo bánh xe sẽ tạo ra bánh xe và chuyển qua bộ phận lắp. Tương tự như vậy, bộ phận tạo khung xe và bộ phân tạo động cợ sẽ tạo ra khung và động cơ, sau đó chuyển sang cho bộ phân lắp ráp. Bộ phận lắp ráp không cần phải biết bánh xe, khung xe hay động cơ xe được tạo ra như thế nào. Chức năng của bộ phận lắp ráp chỉ là ghép các thành phần để tạo ra chiếc xe mà thôi. Bộ phận lắp ráp chính là một HOF, nó nhận output của ba bộ phận còn lại để tạo ra output cho riêng nó. Có thể diễn giải như thế này: 123456789101112131415161718192021222324class BanhXe&#123;&#125; class KhungXe&#123;&#125; class DongCoXe&#123;&#125; // ham tao banh xe def taoBanhXe() = &#123; val banhXe = new BanhXe banhXe &#125; // ham tao khung xe def taoKhungXe() = &#123; val khungXe = new KhungXe khungXe &#125; // ham tao dong co xe def taoDongCoXe() = &#123; val dongCoXe = new DongCoXe dongCoXe &#125; // HOF function def lapRapXe(taoBanhXe(), taoKhungXe(), taoDongCoXe()) Từ ví dụ trên, chúng ta có thể hiểu tính trừu tượng hóa của HOF giúp che giấu chi tiết bên trong một function, làm giảm sự phức tạp. Vấn đề sẽ được xử lý ở một tầng cao hơn, trừu tượng hơn. Tính tái sử dụng (Reusable)Cũng sử dụng ví dụ về dây chuyền tạo ra một chiếc xe. Chúng ta xây dựng một dây chuyền sản xuất xe máy. Tuy nhiên, nếu phải tạo ra thêm một dây chuyền sản xuất xe hơi thêm vào thì sẽ như thế nào ? Tạo ra một dây chuyền mới là giải pháp đơn giản nhất nhưng lại tốn kém về chi phí. Chúng ta có thể bổ sung thêm cho bộ phận tạo bánh xe máy khả năng tạo ra bánh xe hơi. Tương tự như vậy, bộ phận tao khung xe và động cơ đều trang bị thiết bị tạo ra đồng thời linh kiện cho xe máy lẫn xe hơi. Như vậy, ba bộ phân trên đều được sử dụng tùy theo yêu cầu tạo ra sản phẩm. Đó chính là tính tái sử dụng. Cách sử dụng HOF trong ScalaMột bài toán đơn giản được đặt ra, hãy hình dung bạn đang là một ông chủ và muốn tăng lương cho nhân viên của mình. Tăng lương là việc bạn nhân số lương hiện tại của nhân viên với một hệ số nhất định. Bạn nghĩ rằng, việc tăng lương cần linh động do đó phải tạo ra nhiều cách tăng lương khác nhau. Với bài toán trên, chúng ta sẽ đi giải quyết như sau: Để tiện cho việc quản lý vấn đề tăng lương, bạn sử dụng một Object có tên là SalaryRaiser. Bạn có 3 mức tăng lương khác nhau, theo thứ tự tăng dần là: smallPromotion(), greatPromotion() và hugePromotion(). Ở mức smallPromotion, hệ số là 1.1 Ở mức smallPromotion, hệ số là logarit cơ số 10 của số lương hiện tại ứng với nhân viên đó. Ở mức smallPromotion, hệ số là số lương hiện tại của nhân viên đó. Theo cách thông thường, chúng ta sẽ dùng một vòng for để cập nhật giá trị lương của từng nhân viên. Sau đó, trả về danh sách lương của nhân viên sau khi đã cập nhật. Các bạn xem code phía dưới. 123456789101112131415161718192021222324object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * 1.1 &#125; salaries &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * math.log(salaries(i)) &#125; salaries &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * salaries(i) &#125; salaries &#125;&#125; Với HOF, việc viết code trở nên dễ dàng và ngắn gọn hơn khá nhiều. Ở đây, chúng ta sẽ sử dụng một HOF đó là map(). Chúng ta truyền vào map() một function, chính function này sẽ giúp chúng ta thay đổi lương của mỗi nhân viên theo hệ số mong muốn. Hàm map() đã thể hiện tính linh hoạt thông qua việc định nghĩa cách xử lý từng phần tử trong Array. 123456789101112131415object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * 1.1) &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * math.log(salary)) &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * salary) &#125;&#125; Hiện nay đối với Scala, map() là một trong những HOF được dùng nhiều nhất. Ngoài ra, các bạn có thể tìm hiểu thêm về các HOF khác như filter(), flatMap() … Nguồn tham khảo https://discuss.grokking.org/t/higher-order-functions-la-gi-va-d-c-s-d-ng-nh-th-nao/309 https://docs.scala-lang.org/tour/higher-order-functions.html Tác giả: Cao Văn Long","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]}]}