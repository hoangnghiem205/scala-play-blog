{"meta":{"title":"Scala-Play","subtitle":null,"description":null,"author":"scala-play.com","url":"https://scala-play.com"},"pages":[],"posts":[{"title":"Hướng dẫn tích hợp Gitlab-CICD vào dự án của team Best Solution","slug":"intergrated-cicd","date":"2018-10-11T07:27:20.000Z","updated":"2018-10-11T10:17:46.859Z","comments":true,"path":"2018/10/11/intergrated-cicd/","link":"","permalink":"https://scala-play.com/2018/10/11/intergrated-cicd/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;Gần đây, team Best Solution đã tích hợp được Gitlab-CICD vào dự án Green-Blue để tự động hóa quá trình Build, Deploy ứng dụng lên Staging. Dưới đây là hướng dẫn về cách tích hợp Gitlab-CICD cho những dự án khác. Trong hướng dẫn này, mình sử dụng GitLab Community Edition 8.16.3 và Gitlab Runner 1.11.1 1. Tích hợp Gitlab Runner và thêm biến môi trường cho dự án trên Gitlab&nbsp;&nbsp;&nbsp;&nbsp;Để có thể tiến hành quá trình Build-Deploy, Gitlab sử dụng một server có tên là Runner. Tại đây, ứng dụng của chúng ta sẽ được Build,Test, sau đó được Deploy lên server. &nbsp;&nbsp;&nbsp;&nbsp;Hiện tại, Gitlab cung cấp các Shared Runner miễn phí cho chúng ta. Nhưng vì yếu tố bảo mật và đảm bảo hiệu năng, chúng ta nên tự cài đặt một Runner Server riêng phục vụ cho các dự án của công ty. &nbsp;&nbsp;&nbsp;&nbsp;Trong team Best Solution, mình đã cài đặt một Runner Server có tên là the runner. Chúng ta chỉ cần tích hợp Runner vào dự án là có thể sử dụng được. 1.1 Tích hợp Gitlab RunnerChúng ta vào mục Runner (1) của dự án, sẽ thấy màn hình như hình phía dưới. &nbsp;&nbsp;&nbsp;&nbsp;Ở đây có hai phần, Specific Runners và Shared Runners. Như đã nói ở trên, chúng ta chỉ quan tâm tới Specific Runners. Nhìn vào (2), các bạn sẽ thấy một Runner mà mình đã cài đặt sẵn. Để tích hợp Runner vào dự án, chỉ cần nhấn vào nút Enable for this project như (3) là xong. 1.2 Thêm biến môi trường cho dự ánĐể thêm biến môi trường, chúng ta vào mục Variables (1). &nbsp;&nbsp;&nbsp;&nbsp;Đây chính là nơi các bạn khai báo biến môi trường với Gitlab và Runner sẽ sử dụng những biến môi trường này. Có một câu hỏi là: tại sao lại cần biến môi trường ?&nbsp;&nbsp;&nbsp;&nbsp;Mình sẽ lấy ví dụ để trả lời câu hỏi này, các bạn nhìn vào (3). Ở đây mình khai báo một biến môi trường với tên là SSH_PRIVATE_KEY và giá trị của nó sẽ là tất cả các ký tự trong file key mà các bạn sử dụng để ssh lên server khi tiến hành Deploy ứng dụng. Nếu chúng ta không khai báo một key ở đây, thì Runner Server sẽ không thể tiến hành quá trình Deploy được.&nbsp;&nbsp;&nbsp;&nbsp;Với một dự án mới, sẽ không có biến môi trường nào hiển thị ở đây cả. Các bạn sẽ phải tự thêm vào. Đối với team Best Solution, chỉ cần thêm biến SSH_PRIVATE_KEY là đủ. 2. Viết script triển khai ứng dụng lên server&nbsp;&nbsp;&nbsp;&nbsp;Trên server, chúng ta tạo một thư mục để triển khai ứng dụng. Ở đây, mình lấy ví dụ với ứng dụng Gree-Blue, thư mục sẽ giống như hình bên dưới:green-blue-cicd/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ config/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ database.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ log/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ application.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ script/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ deploy.sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ source/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ green-blue-STAGING-20181005172440/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ version/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ green-blue-STAGING-20181005172440.zip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ … Mình sẽ giới thiệu qua mục đích của từng folder trong thư mục chính green-blue-cicd/. Đầu tiên là folder config/, đây là nơi chứa config của ứng dụng. Hiện tại, mình chỉ để config của database trong đó. Chúng ta cần một file config database mẫu để dùng cho quá trình triển khai ứng dụng. Thứ hai là folder log/, đây là nơi chứa log của ứng dụng trong quá trình chạy. Thứ ba là folder script/, mình để script triển khai ứng dụng ở đây. Folder source/ là nơi chứa mã nguồn được giải nén ra từ các phiên bản của ứng dụng nằm bên trong folder version/. Điều quan tâm nhất là script deploy.sh sẽ được viết như thế nào …123456789101112131415161718192021#!/bin/bash# define app nameAPP_NAME=\"green-blue\"# unzip source-codecd /root/web/green-blue-cicd/versionunzip $1.zip -d ../source/# re-config applicationcd /root/web/green-blue-cicd/source/$1/confmv mailer.conf.example mailer.confmv silhouette.conf.example silhouette.confcp /root/web/green-blue-cicd/config/database.conf ./# kill process of prev-versionpid=$(ps -p $(lsof -ti tcp:9000) o pid=)kill -9 $pid# run server &amp; write log filecd /root/web/green-blue-cicd/source/$1/bin/nohup ./$APP_NAME -Dplay.http.secret.key=123123123 -Dplay.evolutions.db.default.autoApply=true -Dhttp.port=9000 &gt; /root/web/green-blue-cicd/log/application.log &amp; &nbsp;&nbsp;&nbsp;&nbsp;Hình ảnh phía trên là nội dung file deploy.sh dùng để triển khai Green-Blue. Trong đó, $1 là tham số truyền vào khi chạy script deploy.sh, ở đây $1 đại diện cho tên của version muốn triển khai. Chúng ta có thể thấy, nội dung file gồm 4 phần:- (1) Giải nén source-code- (2) Cấu hình cho ứng dụng, trong đó có bước lấy file database.conf từ file mẫu ban đầu.- (3) Bỏ bản triển khai trước đó, nó đang chạy ở cổng 9000- (4) Triển khai một version mới và ghi log vào application.log &nbsp;&nbsp;&nbsp;&nbsp;Để triển khai CICD cho một dự án khác, các bạn chỉ cần giữ nguyên cấu trúc thư mục và thay đổi nội dung các file bên trong của nó. Chính xác là chỉ cần thay đổi nội dung file database.conf và file deploy.sh. Nội dung file database.conf sẽ được thay đổi tùy vào các dự án khác nhau. Đối với deploy.sh, chúng ta cần làm 2 việc:- Thay tên của các đường dẫn- Thay tên của ứng dụng trong bước (4). 3. Viết file .gitlab.yml&nbsp;&nbsp;&nbsp;&nbsp;Đầu tiên, chúng ta sẽ đi xem .gitlab-ci.yml của dự án Green-Blue ở đây.Chúng ta sẽ thấy có các phần chính sau: image: docker image được dùng cho quá trình Build - Deploy stages: nơi liệt kê các quá trình được thực thi variables: nơi khai báo các biến môi trường cache: nơi khai báo các thư mục mà bạn muốn cache lại sau mỗi lần Build - Deploy staging: quá trình triển khai ứng dụng lên STAGING &nbsp;&nbsp;&nbsp;&nbsp;Khi viết .gitlab-ci.yml cho một dự án mới, chúng ta chỉ cần quan tâm tới staging, đây là nơi thực thi các câu lệnh tiến hành quá trình Build - Deploy ứng dụng. Các câu lệnh thực thi được chia làm hai phần: a) before_script: các câu lệnh chuẩn bị cho quá trình Deploy, bao gồm các bước:(1) Tạo tên version mới cho ứng dụng12345678# Create VERSION_NAME## Set TIME ZONE- TZ=Asia/Ho_Chi_Minh- ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone## Set VERSION_NAME- export VERSION_NAME=$(date +'%Y%m%d%H%M%S')- echo \"VERSION_NAME is green-blue-STAGING-$&#123;VERSION_NAME&#125;\"- apt-get update -y (2) Cài đặt sbt12345# Install SBT- echo \"deb http://dl.bintray.com/sbt/debian /\" | tee -a /etc/apt/sources.list.d/sbt.list- apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 642AC823- apt-get update -y- apt-get install sbt -y (3) Thay đổi tên version cho ứng dụng123# Change BUILD VERSION- sed -i 's/BUILD_VERSION/'\"STAGING-$&#123;VERSION_NAME&#125;\"'/g' build.sbt- sed -i 's/BUILD_VERSION/'\"green-blue-STAGING-$&#123;VERSION_NAME&#125;\"'/g' public/javascripts/zxcvbnShim.js (4) Thực hiện quá trình Build1- sbt dist (5) Cài đặt ssh12345678# Setup SSH- 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )'# Run ssh-agent (inside the build environment)- eval $(ssh-agent -s)# Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store- ssh-add &lt;(echo \"$SSH_PRIVATE_KEY\")- mkdir -p ~/.ssh- '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' (6) Chuyển mã nguồn sau khi Build lên Staging server12# Send FILE to remote server- scp target/universal/green-blue-STAGING-$&#123;VERSION_NAME&#125;.zip root@133.18.199.250:/root/web/green-blue-cicd/version b) script: các câu lệnh của quá trình Deploy, đây là việc ssh lên Staging và thực thi deploy.sh123- echo \"DEPLOY to STAGING server ...\"# Deploy- ssh root@133.18.199.250 \"sh /root/web/green-blue-cicd/script/deploy.sh green-blue-STAGING-$&#123;VERSION_NAME&#125;\" Chúng ta sẽ phải thay đổi một chút trong khi viết file .gitlab-ci.yml mới.Đối với before_script, chúng ta chỉ cần thay đổi ở các bước (3) và (6): Với bước (3) Thay đổi version := “1.x.x” trong build.sbt thành version := “BUILD_VERSION” Thêm câu lệnh console.log(“Current version is “ + “BUILD_VERSION”) vào đầu file zxcvbnShim.js Với bước (6) thay đổi cái tên green-blue trong đường dẫn target/universal/green-blue-STAGING-${VERSION_NAME}.zip thành tên dự án của bạn. thay đổi đường dẫn /root/web/green-blue-cicd/version cho đúng với đường dẫn với thư mục version/ trên server của bạn. Đối với script: Thay đổi đường dẫn /root/web/green-blue-cicd/script/deploy.sh cho đúng với đường dẫn tới file deploy.sh của bạn trên server. Thay đổi tên green-blue trong green-blue-STAGING-${VERSION_NAME} thành tên dự án của bạn. &nbsp;&nbsp;&nbsp;&nbsp;Đến đây, chúng ta chỉ việc push những gì vừa làm lên branch dev là hoàn thành xong việc tích hợp Gitlab-CICD cho dự án mới.","categories":[{"name":"ci/cd","slug":"ci-cd","permalink":"https://scala-play.com/categories/ci-cd/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://scala-play.com/tags/tutorial/"}]},{"title":"Higher Order Functions trong Scala","slug":"HOF-in-scala","date":"2018-10-02T13:08:24.000Z","updated":"2018-10-06T06:54:44.078Z","comments":true,"path":"2018/10/02/HOF-in-scala/","link":"","permalink":"https://scala-play.com/2018/10/02/HOF-in-scala/","excerpt":"","text":"Định nghĩa Higher Order FunctionHigher Order Function là function thỏa mãn ít nhất một trong hai điều kiện : Có ít nhất một tham số truyền vào là một function khác Kết quả trả về của HOF đó là một function khác. Với Higher Order Function, tính trừu tượng hóa, tái sử dụng chính là điểm mạnh. Tính trừu tượng hóa (Abstraction)Hãy nghĩ đến dây chuyền lắp ráp một chiếc xe. Dây chuyền gồm bốn bộ phận: Bộ phận tạo bánh xe Bộ phận tạo khung xe Bộ phận tạo động cơ Bộ phận lắp ráp Bộ phận tạo bánh xe sẽ tạo ra bánh xe và chuyển qua bộ phận lắp. Tương tự như vậy, bộ phận tạo khung xe và bộ phân tạo động cợ sẽ tạo ra khung và động cơ, sau đó chuyển sang cho bộ phân lắp ráp. Bộ phận lắp ráp không cần phải biết bánh xe, khung xe hay động cơ xe được tạo ra như thế nào. Chức năng của bộ phận lắp ráp chỉ là ghép các thành phần để tạo ra chiếc xe mà thôi. Bộ phận lắp ráp chính là một HOF, nó nhận output của ba bộ phận còn lại để tạo ra output cho riêng nó. Có thể diễn giải như thế này: 123456789101112131415161718192021222324class BanhXe&#123;&#125; class KhungXe&#123;&#125; class DongCoXe&#123;&#125; // ham tao banh xe def taoBanhXe() = &#123; val banhXe = new BanhXe banhXe &#125; // ham tao khung xe def taoKhungXe() = &#123; val khungXe = new KhungXe khungXe &#125; // ham tao dong co xe def taoDongCoXe() = &#123; val dongCoXe = new DongCoXe dongCoXe &#125; // HOF function def lapRapXe(taoBanhXe(), taoKhungXe(), taoDongCoXe()) Từ ví dụ trên, chúng ta có thể hiểu tính trừu tượng hóa của HOF giúp che giấu chi tiết bên trong một function, làm giảm sự phức tạp. Vấn đề sẽ được xử lý ở một tầng cao hơn, trừu tượng hơn. Tính tái sử dụng (Reusable)Cũng sử dụng ví dụ về dây chuyền tạo ra một chiếc xe. Chúng ta xây dựng một dây chuyền sản xuất xe máy. Tuy nhiên, nếu phải tạo ra thêm một dây chuyền sản xuất xe hơi thêm vào thì sẽ như thế nào ? Tạo ra một dây chuyền mới là giải pháp đơn giản nhất nhưng lại tốn kém về chi phí. Chúng ta có thể bổ sung thêm cho bộ phận tạo bánh xe máy khả năng tạo ra bánh xe hơi. Tương tự như vậy, bộ phận tao khung xe và động cơ đều trang bị thiết bị tạo ra đồng thời linh kiện cho xe máy lẫn xe hơi. Như vậy, ba bộ phân trên đều được sử dụng tùy theo yêu cầu tạo ra sản phẩm. Đó chính là tính tái sử dụng. Cách sử dụng HOF trong ScalaMột bài toán đơn giản được đặt ra, hãy hình dung bạn đang là một ông chủ và muốn tăng lương cho nhân viên của mình. Tăng lương là việc bạn nhân số lương hiện tại của nhân viên với một hệ số nhất định. Bạn nghĩ rằng, việc tăng lương cần linh động do đó phải tạo ra nhiều cách tăng lương khác nhau. Với bài toán trên, chúng ta sẽ đi giải quyết như sau: Để tiện cho việc quản lý vấn đề tăng lương, bạn sử dụng một Object có tên là SalaryRaiser. Bạn có 3 mức tăng lương khác nhau, theo thứ tự tăng dần là: smallPromotion(), greatPromotion() và hugePromotion(). Ở mức smallPromotion, hệ số là 1.1 Ở mức smallPromotion, hệ số là logarit cơ số 10 của số lương hiện tại ứng với nhân viên đó. Ở mức smallPromotion, hệ số là số lương hiện tại của nhân viên đó. Theo cách thông thường, chúng ta sẽ dùng một vòng for để cập nhật giá trị lương của từng nhân viên. Sau đó, trả về danh sách lương của nhân viên sau khi đã cập nhật. Các bạn xem code phía dưới. 123456789101112131415161718192021222324object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * 1.1 &#125; salaries &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * math.log(salaries(i)) &#125; salaries &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * salaries(i) &#125; salaries &#125;&#125; Với HOF, việc viết code trở nên dễ dàng và ngắn gọn hơn khá nhiều. Ở đây, chúng ta sẽ sử dụng một HOF đó là map(). Chúng ta truyền vào map() một function, chính function này sẽ giúp chúng ta thay đổi lương của mỗi nhân viên theo hệ số mong muốn. Hàm map() đã thể hiện tính linh hoạt thông qua việc định nghĩa cách xử lý từng phần tử trong Array. 123456789101112131415object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * 1.1) &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * math.log(salary)) &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * salary) &#125;&#125; Hiện nay đối với Scala, map() là một trong những HOF được dùng nhiều nhất. Ngoài ra, các bạn có thể tìm hiểu thêm về các HOF khác như filter(), flatMap() … Nguồn tham khảo https://discuss.grokking.org/t/higher-order-functions-la-gi-va-d-c-s-d-ng-nh-th-nao/309 https://docs.scala-lang.org/tour/higher-order-functions.html","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]}]}