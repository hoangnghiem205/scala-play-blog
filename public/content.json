{"meta":{"title":"Scala-Play","subtitle":null,"description":null,"author":"scala-play.com","url":"https://scala-play.com"},"pages":[],"posts":[{"title":"Scala Collections Tips & Tricks (Phần VI)","slug":"collection-discovery-p6","date":"2018-12-13T03:00:00.000Z","updated":"2019-01-25T03:49:46.948Z","comments":true,"path":"2018/12/13/collection-discovery-p6/","link":"","permalink":"https://scala-play.com/2018/12/13/collection-discovery-p6/","excerpt":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 4 MapKhông tìm kiếm giá trị theo cách thủ công12345// Beforemap.find(_._1 == k).map(_._2)// Aftermap.get(k)","text":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 4 MapKhông tìm kiếm giá trị theo cách thủ công12345// Beforemap.find(_._1 == k).map(_._2)// Aftermap.get(k) Không sử dụng get khi cần giá trị thô12345// Beforemap.get(k).get// Aftermap(k) Sử dụng get thay vì lift12345// Beforemap.lift(k)// Aftermap.get(k) Không gọi get cùng với getOrElse12345// Beforemap.get(k).getOrElse(z)// Aftermap.getOrElse(k, z) Sử dụng Map thể hiện dưới dạng một giá trị hàm12345// Before (map: Map[Int, T])Seq(1, 2, 3).map(map(_))// AfterSeq(1, 2, 3).map(map) Không trích xuất các khóa theo cách thủ công123456789// Beforemap.map(_._1)map.map(_._1).toSetmap.map(_._1).toIterator// Aftermap.keysmap.keySetmap.keysIterator Không trích xuất giá trị theo cách thủ công1234567// Beforemap.map(_._2)map.map(_._2).toIterator// Aftermap.valuesmap.valuesIterator Cẩn thận khi sử dụng filterKeys12345// Beforemap.filterKeys(p)// Aftermap.filter(p(_._1)) Cẩn thận khi sử dụng mapValues12345// Beforemap.mapValues(f)// Aftermap.map(f(_._2)) Không lọc ra các key theo cách thủ công12345// Beforemap.filterKeys(!seq.contains(_))// Aftermap -- seq Sử dụng toán tử gán để gán lại map1234567891011// Beforemap = map + x -&gt; ymap1 = map1 ++ map2map = map - xmap = map -- seq// Aftermap += x -&gt; ymap1 ++= map2map -= xmap --= seq Nguồn tham khảohttps://pavelfatin.com/scala-collections-tips-and-tricks/ Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"discovery","slug":"discovery","permalink":"https://scala-play.com/tags/discovery/"}]},{"title":"Scala Collections Tips & Tricks (Phần V)","slug":"collection-discovery-p5","date":"2018-12-10T03:00:00.000Z","updated":"2019-01-25T03:49:40.972Z","comments":true,"path":"2018/12/10/collection-discovery-p5/","link":"","permalink":"https://scala-play.com/2018/12/10/collection-discovery-p5/","excerpt":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 3. Options3.1 ValueKhông so sánh giá trị của option với None1234567// Beforeoption == Noneoption != None// Afteroption.isEmptyoption.isDefined","text":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 3. Options3.1 ValueKhông so sánh giá trị của option với None1234567// Beforeoption == Noneoption != None// Afteroption.isEmptyoption.isDefined Không so sánh giá trị option với Some1234567// Beforeoption == Some(v)option != Some(v)// Afteroption.contains(v)!option.contains(v) Không dựa vào một phần tử để kiểm tra sự tồn tại của cả mảng12345// Beforeoption.isInstanceOf[Some[_]]// Afteroption.isDefined Không sử dụng match để kiểm tra sự tồn tại1234567891011121314// Beforeoption match &#123; case Some(_) =&gt; true case None =&gt; false&#125;option match &#123; case Some(_) =&gt; false case None =&gt; true&#125;// Afteroption.isDefinedoption.isEmpty Không phủ định các trong các trường hợp sau123456789// Before!option.isEmpty!option.isDefined!option.nonEmpty// Afterseq.isDefinedseq.isEmptyseq.isEmpty 3.2 NullKhông so sánh giá trị với null để khởi tạo option12345// Beforeif (v != null) Some(v) else None// AfterOption(v) Không sử dụng Option với một hằng số12345// BeforeOption(\"constant\")// AfterSome(\"constant\") Không để null khi thay thế12345// Beforeoption.getOrElse(null)// Afteroption.orNull 3.3 ProcessingSử dụng getOrElse12345678910// Beforeif (option.isDefined) option.get else zoption match &#123; case Some(it) =&gt; it case None =&gt; z&#125;// Afteroption.getOrElse(z) Sử dụng orElse123456789if (option1.isDefined) option1 else option2option1 match &#123; case Some(it) =&gt; Some(it) case None =&gt; option2&#125;// Afteroption1.orElse(option2) Sử dụng exists123456789101112// Beforeoption.isDefined &amp;&amp; p(option.get)if (option.isDefined) p(option.get) else falseoption match &#123; case Some(it) =&gt; p(it) case None =&gt; false&#125;// Afteroption.exists(p) Sử dụng forall123456789101112// Beforeoption.isEmpty || (option.isDefined &amp;&amp; p(option.get))if (option.isDefined) p(option.get) else trueoption match &#123; case Some(it) =&gt; p(it) case None =&gt; true&#125;// Afteroption.forall(p) Sử dụng contains123456789101112// Beforeoption.isDefined &amp;&amp; option.get == xif (option.isDefined) option.get == x else falseoption match &#123; case Some(it) =&gt; it == x case None =&gt; false&#125;// Afteroption.contains(x) Sử dụng foreach12345678910// Beforeif (option.isDefined) f(option.get)option match &#123; case Some(it) =&gt; f(it) case None =&gt;&#125;// Afteroption.foreach(f) Sử dụng filter12345678910// Beforeif (option.isDefined &amp;&amp; p(option.get)) option else Noneoption match &#123; case Some(it) &amp;&amp; p(it) =&gt; Some(it) case _ =&gt; None&#125;// Afteroption.filter(p) Sử dụng map12345678910// Beforeif (option.isDefined) Some(f(option.get)) else Noneoption match &#123; case Some(it) =&gt; Some(f(it)) case None =&gt; None&#125;// Afteroption.map(f) Sử dụng flatMap12345678910// Before (f: A =&gt; Option[B])if (option.isDefined) f(option.get) else Noneoption match &#123; case Some(it) =&gt; f(it) case None =&gt; None&#125;// Afteroption.flatMap(f) 3.4 RewritingChuyển đổi map với getOrElse thành fold12345// Beforeoption.map(f).getOrElse(z)// Afteroption.fold(z)(f) Sử dụng exists12345// Beforeoption.map(p).getOrElse(false)// Afteroption.exists(p) Sử dụng flatten123456// Before (option: Option[Option[T]])option.map(_.get)option.getOrElse(None)// Afteroption.flatten Không chuyển đổi option thành một sequence một cách thủ công123456// Beforeoption.map(Seq(_)).getOrElse(Seq.empty)option.getOrElse(Seq.empty) // option: Option[Seq[T]]// Afteroption.toSeq … (còn tiếp) … Nguồn tham khảohttps://pavelfatin.com/scala-collections-tips-and-tricks/ Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"discovery","slug":"discovery","permalink":"https://scala-play.com/tags/discovery/"}]},{"title":"Scala Collections Tips & Tricks (Phần IV)","slug":"collection-discovery-p4","date":"2018-12-06T03:00:00.000Z","updated":"2019-01-25T03:49:27.048Z","comments":true,"path":"2018/12/06/collection-discovery-p4/","link":"","permalink":"https://scala-play.com/2018/12/06/collection-discovery-p4/","excerpt":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 2.SetsKhông sử dụng sameElements để so sánh các collection không có thứ tự12345// Beforeset1.sameElements(set2)// Afterset1 == set2","text":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 2.SetsKhông sử dụng sameElements để so sánh các collection không có thứ tự12345// Beforeset1.sameElements(set2)// Afterset1 == set2 Sử dụng set như một giá trị hàm123456// Before (set: Set[Int])Seq(1, 2, 3).filter(set(_))Seq(1, 2, 3).filter(set.contains)// AfterSeq(1, 2, 3).filter(set) Không tính toán theo cách thủ công12345// Beforeset1.filter(set2)// Afterset1.intersect(set2) // or set1 &amp; set2 Dùng diff sẽ đơn giản hơn`scala// Beforeset1.filterNot(set2) // Afterset1.diff(set2) // or set1 &amp;~ set2… (còn tiếp) … Nguồn tham khảohttps://pavelfatin.com/scala-collections-tips-and-tricks/ Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"discovery","slug":"discovery","permalink":"https://scala-play.com/tags/discovery/"}]},{"title":"Scala Collections Tips & Tricks (Phần III)","slug":"collection-discovery-p3","date":"2018-12-03T03:00:00.000Z","updated":"2019-01-25T03:49:20.868Z","comments":true,"path":"2018/12/03/collection-discovery-p3/","link":"","permalink":"https://scala-play.com/2018/12/03/collection-discovery-p3/","excerpt":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 1. Sequences1.7 SortingKhông sắp xếp thuộc tính theo cách thủ công12345// Beforeseq.sortWith(_.property &lt; _.property)// Afterseq.sortBy(_.property)","text":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 1. Sequences1.7 SortingKhông sắp xếp thuộc tính theo cách thủ công12345// Beforeseq.sortWith(_.property &lt; _.property)// Afterseq.sortBy(_.property) Không sắp xếp identity theo cách thủ công123456// Beforeseq.sortBy(identity)seq.sortWith(_ &lt; _)// Afterseq.sorted Đảo ngược sắp xếp123456789// Beforeseq.sorted.reverseseq.sortBy(_.property).reverseseq.sortWith(f(_, _)).reverse// Afterseq.sorted(Ordering[T].reverse)seq.sortBy(_.property)(Ordering[T].reverse)seq.sortWith(!f(_, _)) Không sử dụng việc sắp xếp để tìm phần tử nhỏ nhất1234567// Beforeseq.sorted.headseq.sortBy(_.property).head// Afterseq.minseq.minBy(_.property) Không sử dụng sắp xếp để tìm phần tử lớn nhất1234567// Beforeseq.sorted.lastseq.sortBy(_.property).last// Afterseq.maxseq.maxBy(_.property) 1.8 ReductionKhông tính tổng theo cách thủ công1234567// Beforeseq.reduce(_ + _)seq.fold(z)(_ + _)// Afterseq.sumseq.sum + z Không tính tích một cách thủ công1234567// Beforeseq.reduce(_ * _)seq.fold(z)(_ * _)// Afterseq.productseq.product * z Không tìm kiếm phần tử nhỏ nhất một cách thủ công1234567// Beforeseq.reduce(_ min _)seq.fold(z)(_ min _)// Afterseq.minz min seq.min Không tìm kiếm phần tử lớn nhất một cách thủ công1234567// Beforeseq.reduce(_ max _)seq.fold(z)(_ max _)// Afterseq.maxz max seq.max Sử dụng forall123456// Beforeseq.foldLeft(true)((x, y) =&gt; x &amp;&amp; p(y))!seq.map(p).contains(false)// Afterseq.forall(p) Sử dụng exist123456// Beforeseq.foldLeft(false)((x, y) =&gt; x || p(y))seq.map(p).contains(true)// Afterseq.exists(p) Sử dụng map123456// Beforeseq.foldLeft(Seq.empty)((acc, x) =&gt; acc :+ f(x))seq.foldRight(Seq.empty)((x, acc) =&gt; f(x) +: acc)// Afterseq.map(f) Sử dụng filter123456// Beforeseq.foldLeft(Seq.empty)((acc, x) =&gt; if (p(x)) acc :+ x else acc)seq.foldRight(Seq.empty)((x, acc) =&gt; if (p(x)) x +: acc else acc)// Afterseq.filter(p) Sử dụng reverse123456// Beforeseq.foldLeft(Seq.empty)((acc, x) =&gt; x +: acc)seq.foldRight(Seq.empty)((x, acc) =&gt; acc :+ x)// Afterseq.reverse 1.9 MatchingDưới đây là một số mẹo thông dụng có liên quan đến tính năng pattern matching và partial functions. Sử dụng partial functions thay cho pattern matching1234567891011// Beforeseq.map &#123; _ match &#123; case P =&gt; ??? // x N &#125;&#125;// Afterseq.map &#123; case P =&gt; ??? // x N&#125; Sử dụng collect thay cho flatMap12345678910// Beforeseq.flatMap &#123; case P =&gt; Seq(???) // x N case _ =&gt; Seq.empty&#125;// Afterseq.collect &#123; case P =&gt; ??? // x N&#125; Sử dụng collect thay cho match khi kết quả là collection12345678910// Beforev match &#123; case P =&gt; Seq(???) // x N case _ =&gt; Seq.empty&#125;// AfterSeq(v) collect &#123; case P =&gt; ??? // x N&#125; Sử dụng collectFirst12345// Beforeseq.collect&#123;case P =&gt; ???&#125;.headOption// Afterseq.collectFirst&#123;case P =&gt; ???&#125; 1.10 RewritingHợp nhất filter12345// Beforeseq.filter(p1).filter(p2)// Afterseq.filter(x =&gt; p1(x) &amp;&amp; p2(x)) Hợp nhất map12345// Beforeseq.map(f).map(g)// Afterseq.map(f.andThen(g)) Sắp xếp sau khi lọc12345// Beforeseq.sorted.filter(p)// Afterseq.filter(p).sorted Không đảo ngược collection trước khi gọi map12345// Beforeseq.reverse.map(f)// Afterseq.reverseMap(f) Không đảo ngược collection trong trường hợp này12345// Beforeseq.reverse.iterator// Afterseq.reverseIterator Không chuyển đổi collection thành Set để tìm các phần tử riêng biệt12345// Beforeseq.toSet.toSeq// Afterseq.distinct Sử dụng slice12345// Beforeseq.drop(x).take(y)// Afterseq.slice(x, x + y) Sử dụng splitAt123456// Beforeval seq1 = seq.take(n)val seq2 = seq.drop(n)// Afterval (seq1, seq2) = seq.splitAt(n) Sử dụng span123456// Beforeval seq1 = seq.takeWhile(p)val seq2 = seq.dropWhile(p)// Afterval (seq1, seq2) = seq.span(p) Sử dụng partition123456// Beforeval seq1 = seq.filter(p)val seq2 = seq.filterNot(p)// Afterval (seq1, seq2) = seq.partition(p) Sử dụng takeRight12345// Beforeseq.reverse.take(n).reverse// Afterseq.takeRight(n) Sử dụng flatten1234567// Before (seq: Seq[Seq[T]])seq.reduce(_ ++ _)seq.fold(Seq.empty)(_ ++ _)seq.flatMap(identity)// Afterseq.flatten Sử dụng flatMap12345// Before (f: A =&gt; Seq[B])seq.map(f).flatten// Afterseq.flatMap(f) Không sử dung map khi kết quả trả về được bỏ qua12345// Beforeseq.map(???) // the result is ignored// Afterseq.foreach(???) Không SỬ dụng unzip để trích xuất 1 thành phần12345// Before (seq: Seq[(A, B]])seq.unzip._1// Afterseq.map(_._1) Không tạo 1 collection tạm thời1. Chuyển đổi collection thành 1 gía trị duy nhất12345// Beforeseq.map(f).flatMap(g).filter(p).reduce(???)// Afterseq.view.map(f).flatMap(g).filter(p).reduce(???) 2. Chuyển đổi tạo ra một collection từ cùng một lớp12345// Beforeseq.map(f).flatMap(g).filter(p)// Afterseq.view.map(f).flatMap(g).filter(p).force Nếu phép chuyển đổi trung gian duy nhất là filter, bạn có thể xem xét sử dụng phương thức withFilter như một phương án thay thế:1seq.withFilter(p).map(f) 3. Chuyển đổi tạo ra một collection của các lớp khác nhau12345// Beforeseq.map(f).flatMap(g).filter(p).toList// Afterseq.view.map(f).flatMap(g).filter(p).toList Có một cách khác để xử lý trường hợp này dựa trên breakOut:1seq.map(f)(collection.breakOut): List[T] Biểu thức như vậy có chức năng tương đương với việc sử dụng một khung nhìn, tuy nhiên cách tiếp cận này: Cần rõ ràng Bị giới hạn trong một chuyển đổi duy nhất. Khá phức tạp Sử dụng toán tử gán để gán lại một chuỗi1234567891011// Beforeseq = seq :+ xseq = x +: seqseq1 = seq1 ++ seq2seq1 = seq2 ++ seq1// Afterseq :+= xseq +:= xseq1 ++= seq2seq1 ++:= seq2 Ngoài ra còn một cú pháp đặc biệt:12345678910111213// Beforelist = x :: listlist1 = list2 ::: list1stream = x #:: streamstream1 = stream2 #::: stream1// Afterlist ::= xlist1 :::= list2stream #::= xstream1 #:::= stream2 Không chuyển đổi collection theo cách thủ công1234567// Beforeseq.foldLeft(Set.empty)(_ + _)seq.foldRight(List.empty)(_ :: _)// Afterseq.toSetseq.toList Hãy cẩn thận với toSeq về các collection không nghiêm ngặt123456// Before (seq: TraversableOnce[T])seq.toSeq// Afterseq.toStreamseq.toVector Bởi vì Seq (…) tạo ra một bộ sưu tập nghiêm ngặt (cụ thể là Vector), chúng ta có thể phải sử dụng toSeq để chuyển đổi một thực thể không nghiêm ngặt (như Stream, Iterator hoặc “view”) thành một collection nghiêm ngặt. Dưới đây là một ví dụ điển hình về lỗ hổng1234val source = Source.fromFile(\"lines.txt\")val lines = source.getLines.toSeqsource.close()lines.foreach(println) Không chuyển đổi chuỗi theo cách thủ công12345678910// Before (seq: Seq[String])seq.reduce(_ + _)seq.reduce(_ + separator + _)seq.fold(prefix)(_ + _)seq.map(_.toString).reduce(_ + _) // seq: Seq[T]seq.foldLeft(new StringBuilder())(_ append _)// Afterseq.mkStringseq.mkString(prefix, separator, \"\") … (còn tiếp) … Nguồn tham khảohttps://pavelfatin.com/scala-collections-tips-and-tricks/ Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"discovery","slug":"discovery","permalink":"https://scala-play.com/tags/discovery/"}]},{"title":"Scala Collections Tips & Tricks (Phần II)","slug":"collection-discovery-p2","date":"2018-11-29T03:00:00.000Z","updated":"2019-01-25T03:49:06.984Z","comments":true,"path":"2018/11/29/collection-discovery-p2/","link":"","permalink":"https://scala-play.com/2018/11/29/collection-discovery-p2/","excerpt":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 1. Sequences1.4 IndexingKhông sử dụng chỉ số để lấy phần tử đầu tiên12345// Beforeseq(0)// Afterseq.head","text":"Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 1. Sequences1.4 IndexingKhông sử dụng chỉ số để lấy phần tử đầu tiên12345// Beforeseq(0)// Afterseq.head Không truy xuất phần tử cuối cùng theo chỉ số12345// Beforeseq(seq.length - 1)// Afterseq.last Không kiểm tra giới hạn chỉ số một cách rõ ràng12345// Beforeif (i &lt; seq.length) Some(seq(i)) else None// Afterseq.lift(i) Không mô phỏng theo headOption123456// Beforeif (seq.nonEmpty) Some(seq.head) else Noneseq.lift(0)// Afterseq.headOption Không mô phỏng theo lastOption123456// Beforeif (seq.nonEmpty) Some(seq.last) else Noneseq.lift(seq.length - 1)// Afterseq.lastOption Cẩn thận khi sử dụng indexOf và lastIndexOf1234567// BeforeSeq(1, 2, 3).indexOf(\"1\") // compilableSeq(1, 2, 3).lastIndexOf(\"2\") // compilable// AfterSeq(1, 2, 3).indexOf(1)Seq(1, 2, 3).lastIndexOf(2) Không xây dựng phạm vi chỉ số theo cách thủ công12345// BeforeRange(0, seq.length)// Afterseq.indices Không nén collection bằng chỉ số của nó theo cách thủ công12345// Beforeseq.zip(seq.indices)// Afterseq.zipWithIndex Sử dụng IndexedSeq như một gía trị hàm12345// Before (seq: IndexedSeq[T])Seq(1, 2, 3).map(seq(_))// AfterSeq(1, 2, 3).map(seq) 1.5 ExistenceCách kiểm tra sự tồn tại của một phần tử12345// Beforeseq.exists(_ == x)// Afterseq.contains(x) Cẩn thận với contains chứa đối số12345// BeforeSeq(1, 2, 3).contains(\"1\") // compilable// AfterSeq(1, 2, 3).contains(1) Cách kiểm tra một phần tử không tồn tại12345// Beforeseq.forall(_ != x)// After!seq.contains(x) Không đếm số lần xuất hiện để kiểm tra sự tồn tại123456789// Beforeseq.count(p) &gt; 0seq.count(p) != 0seq.count(p) == 0// Afterseq.exists(p)seq.exists(p)!seq.exists(p) Không sử dụng filter để kiểm tra sự tồn tại1234567// Beforeseq.filter(p).nonEmptyseq.filter(p).isEmpty// Afterseq.exists(p)!seq.exists(p) Không tìm kiếm để kiểm tra sự tồn tại1234567// Beforeseq.find(p).isDefinedseq.find(p).isEmpty// Afterseq.exists(p)!seq.exists(p) 1.6 FilteringKhông sử dụng phép phủ định trong filter12345// Beforeseq.filter(!p)// Afterseq.filterNot(p) Không sử dụng filter để đếm phần tử12345// Beforeseq.filter(p).length// Afterseq.count(p) Không sử dụng filter để lấy phần tử đầu tiên12345// Beforeseq.filter(p).headOption// Afterseq.find(p) … (còn tiếp) … Nguồn tham khảohttps://pavelfatin.com/scala-collections-tips-and-tricks/ Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"discovery","slug":"discovery","permalink":"https://scala-play.com/tags/discovery/"}]},{"title":"Scala Collections Tips & Tricks (Phần I)","slug":"collection-discovery-p1","date":"2018-11-22T03:00:00.000Z","updated":"2019-01-25T03:48:58.604Z","comments":true,"path":"2018/11/22/collection-discovery-p1/","link":"","permalink":"https://scala-play.com/2018/11/22/collection-discovery-p1/","excerpt":"Bài blog này sẽ giới thiệu tới các bạn một danh sách những cách hay ho để tối ưu việc sử dụng Scala Collections. Vì bài viết khá dài nên mình sẽ chia thành 6 phần để các bạn tiện theo dõi. Và dưới đây là mục lục các bài viết: Bài blog này sẽ giới thiệu tới các bạn một danh sách những cách hay ho để tối ưu việc sử dụng Scala Collections. Vì bài viết khá dài nên mình sẽ chia thành 6 phần để các bạn tiện theo dõi. Và dưới đây là mục lục các bài viết: Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 1. Sequences1.1 CreationTạo collection rỗng một cách rõ ràng.12345// BeforeSeq[T]()// AfterSeq.empty[T]","text":"Bài blog này sẽ giới thiệu tới các bạn một danh sách những cách hay ho để tối ưu việc sử dụng Scala Collections. Vì bài viết khá dài nên mình sẽ chia thành 6 phần để các bạn tiện theo dõi. Và dưới đây là mục lục các bài viết: Bài blog này sẽ giới thiệu tới các bạn một danh sách những cách hay ho để tối ưu việc sử dụng Scala Collections. Vì bài viết khá dài nên mình sẽ chia thành 6 phần để các bạn tiện theo dõi. Và dưới đây là mục lục các bài viết: Phần I: Sequences (Creation &amp; Length &amp; Equality) Phần II: Sequences (Indexing &amp; Existence &amp; Filtering) Phần III: Sequences (Sorting &amp; Reduction &amp; Matching &amp; Rewriting) Phần IV: Sets Phần V: Options Phần VI: Maps 1. Sequences1.1 CreationTạo collection rỗng một cách rõ ràng.12345// BeforeSeq[T]()// AfterSeq.empty[T] Một số collection không thể thay đổi cung cấp các tập rỗng. Tuy nhiên không phải tất cả các phương thức kiểm tra độ dài collection đã tạo. Do đố làm rỗng collection chúng ta có thể tiết kiệm bộ nhớ bằng cách sử dụng lại collecion rỗng. Có thể áp dụng với: Set,Option,Map,Iterator. 1.2 LengthƯu tiên length hơn size cho mảng.12345// Beforearray.size// Afterarray.length Trong khi size và length là 2 từ đồng nghĩa, Scala 2.11 Array.size được gọi thông qua chuyển đổi ngầm, để các đối tượng trung gian được tạo cho mọi phương thức. Trừ khi bạn cho phép escape analysis trong JVM, những đối tượng này có khả năng làm giảm hiệu suất (đặc biệt trong vòng lặp). Không dùng phép phủ định1234567// Before!seq.isEmpty!seq.nonEmpty// Afterseq.nonEmptyseq.isEmpty Không sử dụng phủ định sẽ trực quan hơn. Có thể áp dụng với: Set,Option,Map,Iterator. Không sử dụng length để kiểm tra rỗng123456789// Beforeseq.length &gt; 0seq.length != 0seq.length == 0// Afterseq.nonEmptyseq.nonEmptyseq.isEmpty Không sử dụng length để so sánh độ dài1234567891011// Beforeseq.length &gt; nseq.length &lt; nseq.length == nseq.length != n// Afterseq.lengthCompare(n) &gt; 0seq.lengthCompare(n) &lt; 0seq.lengthCompare(n) == 0seq.lengthCompare(n) != 0 Không sử dụng exist để kiểm tra rỗng123456// Beforeseq.exists(_ =&gt; true)seq.exists(const(true))// Afterseq.nonEmpty 1.3 EqualityKhông sử dụng == để so sánh nội dung các mảng 12345 // Beforearray1 == array2// Afterarray1.sameElements(array2) Không so sánh giữa các collection khác loại.12345// Beforeseq == set// Afterseq.toSet == set Không sử dụng sameElements để so sánh các collection bình thường.12345// Beforeseq1.sameElements(seq2)// Afterseq1 == seq2 Không so sánh tương đối một cách thủ công12345// Beforeseq1.corresponds(seq2)(_ == _)// Afterseq1 == seq2 … (còn tiếp) … Nguồn tham khảohttps://pavelfatin.com/scala-collections-tips-and-tricks/ Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"discovery","slug":"discovery","permalink":"https://scala-play.com/tags/discovery/"}]},{"title":"Collection trong Scala (phần II - phần cuối)","slug":"collection-p2","date":"2018-11-15T03:00:00.000Z","updated":"2019-01-25T03:50:04.561Z","comments":true,"path":"2018/11/15/collection-p2/","link":"","permalink":"https://scala-play.com/2018/11/15/collection-p2/","excerpt":"Functional CombinatorsmapTrả về một danh sách có cùng số phần tử.12345scala&gt; val numbers = List(1, 2, 3, 4)numbers: List[Int] = List(1, 2, 3, 4)scala&gt; numbers.map((i: Int) =&gt; i * 2)res0: List[Int] = List(2, 4, 6, 8)","text":"Functional CombinatorsmapTrả về một danh sách có cùng số phần tử.12345scala&gt; val numbers = List(1, 2, 3, 4)numbers: List[Int] = List(1, 2, 3, 4)scala&gt; numbers.map((i: Int) =&gt; i * 2)res0: List[Int] = List(2, 4, 6, 8) Hoặc truyền vào một hàm:12345scala&gt; def timesTwo(i: Int): Int = i * 2timesTwo: (i: Int)Intscala&gt; numbers.map(timesTwo)res0: List[Int] = List(2, 4, 6, 8) foreachforech giống map nhưng không trả về gì.1scala&gt; numbers.foreach((i: Int) =&gt; i * 2) filterKiểm tra điều kiện của Collection, loại bỏ những phần tử không đáp ứng điều kiện.1234567scala&gt; numbers.filter((i: Int) =&gt; i % 2 == 0)res0: List[Int] = List(2, 4)scala&gt; def isEven(i: Int): Boolean = i % 2 == 0isEven: (i: Int)Booleanscala&gt; numbers.filter(isEven)res2: List[Int] = List(2, 4) zipzip tổng hợp 2 list thành 1 list chứa các cặp phần tử.12scala&gt; List(1, 2, 3).zip(List(\"a\", \"b\", \"c\"))res0: List[(Int, String)] = List((1,a), (2,b), (3,c)) partitionpartition chia tách một list .123scala&gt; val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)scala&gt; numbers.partition(_ % 2 == 0)res0: (List[Int], List[Int]) = (List(2, 4, 6, 8, 10),List(1, 3, 5, 7, 9)) findTrả về phần tử đầu tiên của danh sách thỏa mãn điều kiện.12scala&gt; numbers.find((i: Int) =&gt; i &gt; 5)res0: Option[Int] = Some(6) drop &amp; dropWhiledrop xóa i phần tử đầu tiên trong danh sách.12scala&gt; numbers.drop(5)res0: List[Int] = List(6, 7, 8, 9, 10) dropWhile loại bỏ những phần tử đầu tiên thỏa mãn điều kiện.12scala&gt; numbers.dropWhile(_ % 2 != 0)res0: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10) foldLeft12scala&gt; numbers.foldLeft(0)((m: Int, n: Int) =&gt; m + n)res0: Int = 55 number là một List[Int] và m hoạt động như một bộ tích lũy.123456789101112scala&gt; numbers.foldLeft(0) &#123; (m: Int, n: Int) =&gt; println(\"m: \" + m + \" n: \" + n); m + n &#125;m: 0 n: 1m: 1 n: 2m: 3 n: 3m: 6 n: 4m: 10 n: 5m: 15 n: 6m: 21 n: 7m: 28 n: 8m: 36 n: 9m: 45 n: 10res0: Int = 55 foldRightGiống foldLeft nhưng chạy ngược lại.123456789101112scala&gt; numbers.foldRight(0) &#123; (m: Int, n: Int) =&gt; println(\"m: \" + m + \" n: \" + n); m + n &#125;m: 10 n: 0m: 9 n: 10m: 8 n: 19m: 7 n: 27m: 6 n: 34m: 5 n: 40m: 4 n: 45m: 3 n: 49m: 2 n: 52m: 1 n: 54res0: Int = 55 flatten12scala&gt; List(List(1, 2), List(3, 4)).flattenres0: List[Int] = List(1, 2, 3, 4) flatMapflatMap hoạt động trên danh sách lồng nhau, sau đó gộp kết quả vào nhau.12345scala&gt; val nestedNumbers = List(List(1, 2), List(3, 4))nestedNumbers: List[List[Int]] = List(List(1, 2), List(3, 4))scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * 2))res0: List[Int] = List(2, 4, 6, 8) 12scala&gt; nestedNumbers.map((x: List[Int]) =&gt; x.map(_ * 2)).flattenres1: List[Int] = List(2, 4, 6, 8) Generalized functional combinatorsBây giờ chúng ta đã học được các function làm việc với collection. Chúng ta có thể viết một chức năng xử lý collection của riêng mình. Ex:12345678def ourMap(numbers: List[Int], fn: Int =&gt; Int): List[Int] = &#123; numbers.foldRight(List[Int]()) &#123; (x: Int, xs: List[Int]) =&gt; fn(x) :: xs &#125;&#125;scala&gt; ourMap(numbers, timesTwo(_))res0: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) MapTất cả function đều hoạt động trên Map, Map là một danh sách các cặp key - value.12scala&gt; val extensions = Map(\"steve\" -&gt; 100, \"bob\" -&gt; 101, \"joe\" -&gt; 201)extensions: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101), (joe,201)) Bây giờ lọc ra giá trị value nhỏ hơn 200.12scala&gt; extensions.filter((namePhone: (String, Int)) =&gt; namePhone._2 &lt; 200)res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101)) Chúng ta có thể sử dụng pattern matching để trích xuất ra giá trị.12scala&gt; extensions.filter(&#123;case (name, extension) =&gt; extension &lt; 200&#125;)res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101)) Nguồn tham khảo:https://twitter.github.io/scala_school/collections.html Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Collection trong Scala (phần I)","slug":"collection-p1","date":"2018-11-12T03:00:00.000Z","updated":"2019-01-25T03:49:58.029Z","comments":true,"path":"2018/11/12/collection-p1/","link":"","permalink":"https://scala-play.com/2018/11/12/collection-p1/","excerpt":"Đây là bài viết khá hay về collection trong Scala. Vì bài viết tương đối dài nên mình sẽ chia làm hai bài blog để các bạn tiện theo dõi. Chủ đề chúng ta sẽ follow trong hai bài blog đó là: Basic Data Structures: Collection trong Scala (phần I) Functional Combinators: Collection trong Scala (phần II - phần cuối) Basic Data StructuresScala cung cấp một số collection rất hữu dụng. ArrayArray có trật tự, có thể lưu các bản sao của các phần tử và có thể thay đôi được.1234scala&gt; val numbers = Array(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)numbers: Array[Int] = Array(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)scala&gt; numbers(3) = 10","text":"Đây là bài viết khá hay về collection trong Scala. Vì bài viết tương đối dài nên mình sẽ chia làm hai bài blog để các bạn tiện theo dõi. Chủ đề chúng ta sẽ follow trong hai bài blog đó là: Basic Data Structures: Collection trong Scala (phần I) Functional Combinators: Collection trong Scala (phần II - phần cuối) Basic Data StructuresScala cung cấp một số collection rất hữu dụng. ArrayArray có trật tự, có thể lưu các bản sao của các phần tử và có thể thay đôi được.1234scala&gt; val numbers = Array(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)numbers: Array[Int] = Array(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)scala&gt; numbers(3) = 10 ListsList có trật tự, có thể lưu các bản sao của các phần tử và có thể thay đổi được. 123456scala&gt; val numbers = List(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)numbers: List[Int] = List(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)scala&gt; numbers(3) = 10&lt;console&gt;:9: error: value update is not a member of List[Int] numbers(3) = 10 SetsSet không có trật tự và không thể lưu các bản sao của các phần tử . 12scala&gt; val numbers = Set(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)numbers: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4) TupleTuple nhóm các phần tử lại mà không sử dụng một Class. 12scala&gt; val hostPort = (\"localhost\", 80)hostPort: (String, Int) = (localhost, 80) Không giống các case class, chúng không có tên truy nhập, thay vào đó chúng được truy nhập theo vị trí.12345scala&gt; hostPort._1res0: String = localhostscala&gt; hostPort._2res1: Int = 80 Pattern matching với tuple.1234hostPort match &#123; case (\"localhost\", port) =&gt; ... case (host, port) =&gt; ...&#125; MapNó có thể chứa các kiểu dữ liệu cơ bản. 12Map(1 -&gt; 2)Map(\"foo\" -&gt; \"bar\") Map được sử dụng cú pháp đối số. Map(1 -&gt; &quot;one&quot;, 2 -&gt; &quot;two&quot;) giống như Map((1, &quot;one&quot;), (2, &quot;two&quot;))với giá trị đầu là key và giá trị tiếp theo là value. Map có thể chứa nhiều kiểu giá trị12Map(1 -&gt; Map(\"foo\" -&gt; \"bar\"))Map(\"timesTwo\" -&gt; &#123; timesTwo(_) &#125;) OptionOption là một container có thể có dữ liệu hoặc không có gì. Interface cơ bản của Option giống như:12345trait Option[T] &#123; def isDefined: Boolean def get: T def getOrElse(t: T): T&#125; Option có 2 lớp tùy chọn là: Some[T] hoặc None Hãy xem một ví dụ về cách sử dụng Option: 12345678910Map.get uses Option for its return type. Option tells you that the method might not return what you’re asking for.scala&gt; val numbers = Map(\"one\" -&gt; 1, \"two\" -&gt; 2)numbers: scala.collection.immutable.Map[java.lang.String,Int] = Map(one -&gt; 1, two -&gt; 2)scala&gt; numbers.get(\"two\")res0: Option[Int] = Some(2)scala&gt; numbers.get(\"three\")res1: Option[Int] = None Dữ liệu trên sẽ bị lỗi. Làm sao để làm việc với nó? Sử dụng isDefined123456// We want to multiply the number by two, otherwise return 0.val result = if (res1.isDefined) &#123; res1.get * 2&#125; else &#123; 0&#125; Bạn nên sử dụng getOrElse, vì nó cho phép bạn dễ dàng gán giá trị mặc định.1val result = res1.getOrElse(0) * 2 Pattern matching với Option:1234val result = res1 match &#123; case Some(n) =&gt; n * 2 case None =&gt; 0&#125; … (còn tiếp) … Nguồn tham khảo:https://twitter.github.io/scala_school/collections.html Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Trait trong Scala","slug":"scala-trait","date":"2018-11-08T03:00:00.000Z","updated":"2019-01-25T03:50:31.589Z","comments":true,"path":"2018/11/08/scala-trait/","link":"","permalink":"https://scala-play.com/2018/11/08/scala-trait/","excerpt":"Scala traitTrait bao gồm các định nghĩa về phương thức và trường, và có thể được sử dụng bằng cách kế thừa vào trong class. Không giống như kế thừa class, mỗi một class chỉ được kế thừa 1 class cha, một class có thể kế thừa nhiều trait. Trait được sử dụng để định nghĩa loại đối tượng bằng cách sử dụng các phương thức được hỗ trợ. Scala cũng cho phép trait thực thi một phần nhưng trait không có tham số.Một trait được định nghĩa giống như một class được định nghĩa ngoại trừ nó sử dụng từ khóa trait. Theo dõi ví dụ đơn giản về cú pháp của trait.","text":"Scala traitTrait bao gồm các định nghĩa về phương thức và trường, và có thể được sử dụng bằng cách kế thừa vào trong class. Không giống như kế thừa class, mỗi một class chỉ được kế thừa 1 class cha, một class có thể kế thừa nhiều trait. Trait được sử dụng để định nghĩa loại đối tượng bằng cách sử dụng các phương thức được hỗ trợ. Scala cũng cho phép trait thực thi một phần nhưng trait không có tham số.Một trait được định nghĩa giống như một class được định nghĩa ngoại trừ nó sử dụng từ khóa trait. Theo dõi ví dụ đơn giản về cú pháp của trait. Cú pháp:1234trait Equal &#123; def isEqual(x: Any): Boolean def isNotEqual(x: Any): Boolean = !isEqual(x)&#125; Trait bao gồm 2 phương thức isEqual và isNotEqual. Ở đây, chúng tôi không thực hiện isEqual khi có một phương thức khác đã thực hiện. Lớp con kế thừa một trait có thể thực hiện hoặc không thực hiện phương thức. Vì vậy một trait rất giống abstract class trong java. Hãy để chúng tôi giả định môt ví dụ của trait Equal trong 2 phương thức isEqual() và isNotEqual(). Trait chứa hàm so sánh chỉ thực hiện 1 phương thức isEqual() vì vậy khi người sử dụng định nghĩa class Point kế thừa trait Equal thực hiện phương thức isEqual() trong class Point cần phải được cung cấpỞ đây rất cần thiết để biết 2 phương thức quan trọng của Scala, được sử dụng ở ví dụ dưới. obj.isInstanceOf [Point] để kiểm tra loại đối tượng obj và Point là giống hay khác. obj.asInstanceOf [Point] nghĩa là đúc chính xác loại đối tượng obj và trả về cùng một obj như Point. Thử theo dõi chương trình ví dụ dưới đây để thực hiện Trait.12345678910111213141516171819202122 trait Equal &#123; def isEqual(x: Any): Boolean def isNotEqual(x: Any): Boolean = !isEqual(x)&#125;class Point(xc: Int, yc: Int) extends Equal &#123; var x: Int = xc var y: Int = yc def isEqual(obj: Any) = obj.isInstanceOf[Point] &amp;&amp; obj.asInstanceOf[Point].x == y&#125;object Demo &#123; def main(args: Array[String]) &#123; val p1 = new Point(2, 3) val p2 = new Point(2, 4) val p3 = new Point(3, 3) println(p1.isNotEqual(p2)) println(p1.isNotEqual(p3)) println(p1.isNotEqual(2)) &#125;&#125; Lưu vào chương trình Demo.scala. Các lệnh sau được sử dụng để biên dịch và chạy chương trình này: Command:12\\&gt;scalac Demo.scala\\&gt;scala Demo Output123truefalsetrue Value classes và Universal TraitsValue classes là cơ chế mới trong Scala để tránh phân bổ thời gian chạy của các đối tượng. Nó chứa một hàm tạo chính và chính xác 1 tham số val. Nó chỉ chứa các phương thức (def) không có var, val, các lớp lồng nhau, trait hoặc đối tượng. Value classes không thế được kế thừa bởi class khác. Nó có thể khả thi khi kế thừa value class với AnyVal. Hãy để chúng tôi làm một ví dụ về value classes Weight, Height,Email,Age, … Đối với tất cả các ví dụ này không cần phải cấp phát bộ nhớ cho ứng dụng.Một value classes không được phép kế thừa Trait. Để cho phép value classes kế thừa trait, universal traits được giới thiệu và được kế thừa cho bất kỳ value classes nào. Example1234567891011trait Printable extends Any &#123; def print(): Unit = println(this)&#125;class Wrapper(val underlying: Int) extends AnyVal with Printableobject Demo &#123; def main(args: Array[String]) &#123; val w = new Wrapper(3) w.print() // actually requires instantiating a Wrapper instance &#125;&#125; Lưu vào chương trình Demo.scala. Các lệnh sau được sử dụng để biên dịch và chạy chương trình này: Command12\\&gt;scalac Demo.scala\\&gt;scala Demo Output1Wrapper@13 Khi nào sử dụng Trait?Không có một quy luật chắc chắn, nhưng đây là một ít hướng dẫn để xem xét: Nếu hành vi không được tái sử dụng, làm nó trở thành một lớp thực. Nó không phải là hành vi sử dụng sau tất cả. Nếu nó được tái sử dụng trong unrelated classes, cho nó là trait. Chỉ trait có thể được kế thừa vào các thành phần khác nhau của lớp. Nếu bạn muốn thừa kế từ nó trong java code, sử dụng một abstract class Nếu bạn có ý tưởng phân tán nó trong một dạng biên dịch, và bạn chờ đợi các lớp bên ngoài kế thừa từ nó, bạn nên sử dụng abstract class. nếu hiêu quả quan trọng, nghiêng về sử dụng class. Nguồn tham khảohttps://www.tutorialspoint.com/scala/scala_traits.htm https://docs.scala-lang.org/overviews/collections/trait-iterable.html Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Case Class trong Scala","slug":"case-class","date":"2018-11-05T03:00:00.000Z","updated":"2019-01-25T03:48:52.280Z","comments":true,"path":"2018/11/05/case-class/","link":"","permalink":"https://scala-play.com/2018/11/05/case-class/","excerpt":"Case classCase class giống như class thông thường với một vài từ khóa khác mà chúng ta hay sử dụng. Case class thường được sử dụng cho việc mô hình hóa dữ liệu bất biến. Định nghĩa case classMột case class tối thiểu cần có từ khóa case class, một định danh, và một danh sách các tham số (có thể trống)12case class Book(isbn: String) val frankenstein = Book(\"978-0486282114\")","text":"Case classCase class giống như class thông thường với một vài từ khóa khác mà chúng ta hay sử dụng. Case class thường được sử dụng cho việc mô hình hóa dữ liệu bất biến. Định nghĩa case classMột case class tối thiểu cần có từ khóa case class, một định danh, và một danh sách các tham số (có thể trống)12case class Book(isbn: String) val frankenstein = Book(\"978-0486282114\") Lưu ý từ khóa new không được sử dụng trong khởi tạo case class Book. Bởi vì case class có một phương thức apply mặc định trong cấu trúc của đối tượng. Khi bạn tạo mới một case class với tham số, tham số được công khai sử dụng12345case class Message(sender: String, recipient: String, body: String) val message1 = Message(\"guillaume@quebec.ca\", \"jorge@catalonia.es\", \"Ça va ?\")println(message1.sender) // prints guillaume@quebec.ca message1.sender = \"travis@washington.us\" // this line does not compile Bạn không thể gán lại giá trị messager1.sender bởi vì nó được khai báo val (giá trị không thay đổi). Có thể sử dụng var s trong case class nhưng không được khuyến khích. So sánhCase class được so sánh bằng cấu trúc và không phải bằng tham chiếu :1234case class Message(sender: String, recipient: String, body: String) val message2 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\") val message3 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\") val messagesAreTheSame = message2 == message3 // true Mặc dù message2 và message3 là 2 đối tượng khác nhau nhưng giá trị của 2 đối tượng bằng nhau. CopyingBạn có thể tạo mới một bản sao của một case class đơn giản sử dụng phương thức copy. Bạn có thể tùy chọn sửa chữa giá trị .123456case class Message(sender: String, recipient: String, body: String) val message4 = Message(\"julien@bretagne.fr\", \"travis@washington.us\", \"Me zo o komz gant ma amezeg\") val message5 = message4.copy(sender = message4.recipient, recipient = \"claire@bourgogne.fr\") message5.sender // travis@.message5.recipient // claire@bourgogne.fr message5.body // \"Me zo o komz gant ma amezeg\" Người nhận message4 được dùng để gửi tiếp tin nhắn 5 nhưng phần thân của tin nhắn 4 được sao chép trực tiếp. Nguồn tham khảo:https://docs.scala-lang.org/tour/case-classes.html https://www.tutorialspoint.com/scala Biên tập: Nguyễn Văn Linh","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Làm việc với Slick trong Play Framework","slug":"slick","date":"2018-10-30T03:00:00.000Z","updated":"2019-01-25T03:50:48.333Z","comments":true,"path":"2018/10/30/slick/","link":"","permalink":"https://scala-play.com/2018/10/30/slick/","excerpt":"I. ORMORM (Object Relational Mapping) là một kỹ thuật lập trình ánh xạ từ cơ sở dữ liệu sang đối tượng trong các ngôn ngữ lập trình hướng đối tượng như Java,Scala … (các table tương ứng với các class, quan hệ giữa các table tương ứng với quan hệ giữa các class). Sử dụng ORM cho phép người lập trình thao tác với database một cách dễ dàng thông qua các đối tượng mà không cần trực tiếp quan tâm tới database.Một số framework sử dụng kỹ thuật ORM: Play Scala sử dụng Slick, Sping Java sử dụng Hibernate…","text":"I. ORMORM (Object Relational Mapping) là một kỹ thuật lập trình ánh xạ từ cơ sở dữ liệu sang đối tượng trong các ngôn ngữ lập trình hướng đối tượng như Java,Scala … (các table tương ứng với các class, quan hệ giữa các table tương ứng với quan hệ giữa các class). Sử dụng ORM cho phép người lập trình thao tác với database một cách dễ dàng thông qua các đối tượng mà không cần trực tiếp quan tâm tới database.Một số framework sử dụng kỹ thuật ORM: Play Scala sử dụng Slick, Sping Java sử dụng Hibernate… Ưu nhược điểm của ORM:Ưu điểm: Giúp người lập trình tập trung vào hướng đối tượng. Làm việc được với nhiều loại database, nhiều kiểu dữ liệu khác nhau, dễ dàng thay đổi loại database. Các câu lệnh SQL không phụ thuộc vào loại database. Đơn giản, dễ sử dụng: Hỗ trợ HSQL , cung cấp nhiều kiểu API truy vấn. Năng suất hơn: viết code ít hơn, phù hợp với các case Có thể sử dụng lại code. Nhược điểm: Khả năng truy vấn bị hạn chế, nhiều trường hợp ta vẫn phải sử dụng native SQL để truy vấn database. Khó tối ưu câu lệnh SQL (do câu lệnh SQL được ORM tự động sinh ra). II. Truy vấn ORM với slick scala:Với các bảng có mối quan hệ sau: Mối quan hệ của các bảng: student - teacher : N-N student - classes : 1-N teacher - classes : 1-N student - student_teacher : 1-N teacher - student_teacher : 1-N Ta sẽ thực hiện các trường hợp truy vấn và kết quả từ database khác nhau.Trường hợp 1: Xét bảng student:12def searchStudentWhere(id: Int): Future[Seq[Tables.Student]] = db.run(studentTable.filter(_.studentId === id).sortBy(_.studentId).result) Trường hợp 2: Xét bảng classes - student: 1-N1234567def searchStudentClassOrder(): Future[Seq[(Student, Option[Classes])]] = &#123; val action = (for &#123; (a, b) &lt;- studentTable joinLeft classesTable on (_.classId === _.classId) &#125; yield (a, b)).filter(_._1.studentId === id)db.run(action.sortBy(_._1.studentId).result) &#125; Trường hợp 3: Xét bảng student - teacher: N-N với bảng trung gian student_teacher1234567def searchStudentTeacherWhere(id: Int): Future[Seq[(StudentTeacher, Option[Student], Option[Teacher])]] = &#123; val action = (for &#123; ((a, b), c) &lt;- (studentTeacherTable jo inLeft studentTable on (_.studentId === _.studentId)) joinLeft teacherTable on (_._1.teacherId === _.teacherId) &#125; yield (a, b, c)).filter(_._3.map(_.teacherId) === id).sortBy(_._3.map(_.teacherId)) db.run(action.result) &#125; Trường hợp 4: Xét 3 bảng Student - teacher - classes12345678910def searchStudentClassTeacherWhere(id: Int): Future[Seq[(Tables.StudentTeacher, Option[Student], Option[Teacher], Option[Classes])]] = &#123; val action = (for &#123; (((a, b), c), d) &lt;- ((studentTeacherTable joinLeft studentTable on (_.studentId === _.studentId)) joinLeft teacherTable on (_._1.teacherId === _.teacherId)) joinLeft classesTable on (_._2.map(_.classId.getOrElse(0)) === _.classId) &#125; yield (a, b, c, d)).filter(_._4.map(_.classId) === id).sortBy(_._3.map(_.teacherId)) db.run(action.result) &#125; III. Plain SQLĐôi khi bạn cần phải viết trực tiếp mã SQL cho một hoạt động không được hỗ trợ trong ORM, thay vì quay lại JDBC bạn có thể sử dụng SQL Plain. Bạn chỉ cần làm rõ các trường của đối tượng với các trường trong bảng database (thay vì ánh xạ chúng) bằng cách sử dụng thư viện GetResult có sẵn trong slick123456import slick.jdbc.GetResultimplicit val GetStudentResults = GetResult(r =&gt; Student(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;))implicit val GetClassResults = GetResult(r =&gt; Tables.Classes(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;))implicit val GetTeacherResults = GetResult(r =&gt; Teacher(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;))implicit val GetStudentTeacherResults = GetResult(r =&gt; StudentTeacher(r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;, r.&lt;&lt;)) Một số câu truy vấn: Trường hợp 1: Xét bảng student:1234def searchStudentWhereSql(id: Int): Future[Seq[Tables.Student]] = &#123; val action = sql\"select *from student where student_id = $id order by student_id\".as[Student] db.run(action)&#125; Trường hợp 2: Xét bảng classes - student: 1-N1234def searchStudentClassWhereSql(id: Int): Future[Vector[(Student, Classes)]] = &#123; val action = sql\"select *from student a left join classes b on a.class_id = b.class_id where a.student_id = $id order by a.class_id\".as[(Student, Classes)] db.run(action)&#125; Trường hợp 3: Xét bảng student - teacher: N-N với bảng trung gian student_teacher12345678910def searchStudentTeacherWhereSql(id: Int): Future[Vector[(Student, StudentTeacher, Teacher)]] = &#123; val action = sql\"\"\"select * from student a left join student_teacher b on a.student_id = b.student_id left join teacher c on b.teacher_id = c.teacher_id where c.teacher_id = $id order by a.student_id;\"\"\".as[(Student, StudentTeacher, Teacher)] db.run(action)&#125; Trường hợp 4: Xét 3 bảng Student - teacher - classes12345678910def searchStudentClassTeacherWhereSql(id: Int): Future[Vector[(Student, StsudentTeacher, Teacher, Classes)]] = &#123; val action = sql\"\"\"select * from student a left join student_teacher b on a.student_id = b.student_id left join teacher c on b.teacher_id = c.teacher_id left join classes d on c.class_id = d.class_id where a.class_id = $id;\"\"\".as[(Student, StudentTeacher, Teacher, Classes)] db.run(action)&#125; IV. So sánh ORM với Plain SQL - Plain SQL ORM Hiệu năng Nhanh hơn chậm hơn Tối ưu Dễ tối ưu hơn Khó tối ưu hơn Tính năng động Phải thay đổi code khi thay đổi loại database sử dụng Tương thích với nhiều loại database mà ORM hỗ trợ, không cần thay đổi code khi thay đổi loại database Khả năng sử dụng lại code Không Có Nguồn tham khảo:http://slick.lightbend.com/doc/3.0.0/introduction.html Tác giả: Nguyễn Văn Linh","categories":[{"name":"play","slug":"play","permalink":"https://scala-play.com/categories/play/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Twirl template engine trong Play Framework","slug":"twirl-template-engine","date":"2018-10-25T10:00:00.000Z","updated":"2019-01-25T03:50:54.681Z","comments":true,"path":"2018/10/25/twirl-template-engine/","link":"","permalink":"https://scala-play.com/2018/10/25/twirl-template-engine/","excerpt":"Template engine là gì ?Template engine là một bộ xử lí template thường được viết bằng ngôn ngữ back-end . Cho phép xử lí nghiệp vụ logic ở tầng view , giúp luồng code làm việc dễ dàng và linh hoạt hơn Giúp xử lí ,truy xuất , tính toán ,hiển thị hiệu quả dữ liệu ở trong phần giao diện . Ở runtime, template engine thay thế những biến trong template với giá trị thực và chuyển đổi template thành file HTML gửi tới client.","text":"Template engine là gì ?Template engine là một bộ xử lí template thường được viết bằng ngôn ngữ back-end . Cho phép xử lí nghiệp vụ logic ở tầng view , giúp luồng code làm việc dễ dàng và linh hoạt hơn Giúp xử lí ,truy xuất , tính toán ,hiển thị hiệu quả dữ liệu ở trong phần giao diện . Ở runtime, template engine thay thế những biến trong template với giá trị thực và chuyển đổi template thành file HTML gửi tới client. Ví dụ : Javascript thì có một số template engine như Mustache, EJS . PHP thì có Twig, Smarty ,Mustache. Java thì có Apache Velocity,Thymeleaf, Apache FreeMaker,Groovy. Twirl là gì ?Khái niệm: Twirl là 1 bộ xử lí template dựa trên scala đi kèm với Play framework cho phép luồng code dễ dàng , chặt chẽ ,linh hoạt . Ví dụ: Khi bạn cần hiển thị một bảng với số lượng hàng chưa biết trước, sẽ rất vất vả khi mà bạn phải code thuần cả table đó. Thay cho việc đó, chúng ta dùng template engine. Template engine dựng khung table đủ các cột và 1 dòng chỉ định đến dữ liệu tương ứng, dữ liệu sẽ theo từng trường hợp hiện thị phù hợp.123456789101112131415161718&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Class&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @for(student &lt;- students)&#123; &lt;tr&gt; &lt;td&gt;@student.name&lt;/td&gt; &lt;td&gt;@student.className&lt;/td&gt; &lt;td&gt;@student.address&lt;/td&gt; &lt;/tr&gt; &#125; &lt;/tbody&gt; &lt;/table&gt; Tại sao lại chọn twirl ? [Chặt chẽ, biểu cảm , linh hoạt ] : nó giảm thiểu số lượng ký tự và tổ hợp phím được yêu cầu trong một tệp và cho phép luồng công việc mã hóa nhanh, linh hoạt.Không giống như hầu hết các cú pháp mẫu, bạn không cần phải ngắt mã hóa của mình để biểu thị rõ ràng các khối máy chủ trong HTML của bạn. Trình phân tích cú pháp đủ thông minh để suy ra điều này từ mã của bạn. Điều này cho phép một cú pháp thực sự nhỏ gọn và biểu cảm, sạch sẽ, nhanh chóng và thú vị để nhập. [Dễ học] : nó cho phép bạn nhanh chóng trở nên năng suất, với tối thiểu các khái niệm. Bạn chỉ cần sử dụng các cấu trúc Scala đơn giản và tất cả các kỹ năng HTML hiện có của bạn [Không phải là một ngôn ngữ mới] : Cho phép các nhà phát triển Scala sử dụng các kỹ năng ngôn ngữ Scala hiện có và cung cấp cú pháp đánh dấu mẫu cho phép tạo luồng công việc xây dựng HTML tuyệt vời. [Có thể chỉnh sửa trong bất kì trình soạn thảo văn bản nào] :nó không yêu cầu một công cụ cụ thể và cho phép bạn làm việc hiệu quả trong bất kỳ trình soạn thảo văn bản thuần tuý nào. Cú pháp của twirl ?Play scala template đơn giản là 1 file text đơn giản gồm những khối code scala nhỏ.Templates có thể sinh ra bất kì định dạng text nào như là HTML, XML, CSV. Các template được biên dịch thành các hàm Scala chuẩn, theo một quy ước đặt tên đơn giản. Nếu bạn tạo một file template views/Application/index.scala.html , nó sẽ sinh ra một lớp views.html.Application.index gắn với phương thức apply(). Đây là một template đơn giản: 12345678@(teachers: List[Teacher])&lt;h1&gt;Welcome @customer.name!&lt;/h1&gt;&lt;ul&gt; @for(teacher &lt;- teachers) &#123; &lt;li&gt;@teacher.name&lt;/li&gt; &#125;&lt;/ul&gt; Sau đó bạn có thể gọi nó từ bất kỳ mã Scala nào như bạn thường gọi một phương thức trên một lớp: 1val content = views.html.Application.index(teachers); Một scala template là một file HTML với những câu lệnh scala được nhúng vào và bắt đầu bằng kí tự @.Một template cũng là 1 hàm ,nó cần tham số và được khai báo ở dòng đầu tiên của file template. Ví dụ:12@(teachers: List[Teacher])@(title: String = \"Home\") NHỮNG TRƯỜNG HỢP HAY SỬ DỤNGPhép lặp12345&lt;ul&gt;@for(p &lt;- products) &#123; &lt;li&gt;@p.name (@p.price)&lt;/li&gt;&#125;&lt;/ul&gt; Khối if12345@if(items.isEmpty) &#123; &lt;h1&gt;Nothing to display&lt;/h1&gt;&#125; else &#123; &lt;h1&gt;@items.size items!&lt;/h1&gt;&#125; Tạo khối code có thể dùng lại123456789@display(product: Product) = &#123; @product.name (@product.price)&#125;&lt;ul&gt;@for(product &lt;- products) &#123; @display(product)&#125;&lt;/ul&gt; Comment123@********************* This is a comment **********************@ Pattern matching12345678@user match &#123; case Some(name) =&gt; &#123; &lt;span class=”admin”&gt; Connect to (@name) &lt;/span&gt; &#125; case None =&gt; &#123; &lt;span&gt; Not logged &lt;/span&gt; &#125;&#125; Import12@import utils._@import models. LAYOUT[1] Khai báo [views/main.scala.html] hoạt động như một layout template chính:12345678910@(title: String)(content: Html)&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;@title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;section class=\"content\"&gt;@content&lt;/section&gt; &lt;/body&gt;&lt;/html&gt; [2] Như bạn thấy, mẫu này có hai tham số: title và block code HTML. Bây giờ chúng ta có thể tái sử dụng nó từ một template khác [views/Application/index.scala.html]123@main(title = \"Home\") &#123; &lt;h1&gt;Home page&lt;/h1&gt;&#125; Nhận xét về độ tiện lợi của twirlTwirl giúp tiết kiệm thời gian khi viết đi viết lại cấu trúc code phổ biến. Nguồn tham khảo:https://www.playframework.com/documentation/2.5.x/ScalaTemplateshttps://alvinalexander.com/scala/create-play-framework-template-functions-exampleshttps://www.slideshare.net/knoldus/knolx-pte Tác giả: Nguyễn Đình Cường","categories":[{"name":"play","slug":"play","permalink":"https://scala-play.com/categories/play/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Giới thiệu về List trong Scala","slug":"scala-lists","date":"2018-10-16T02:11:35.000Z","updated":"2019-01-25T03:50:18.789Z","comments":true,"path":"2018/10/16/scala-lists/","link":"","permalink":"https://scala-play.com/2018/10/16/scala-lists/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;List trong scala gần tương tự như mảng, vì mọi phần tử đều cùng kiểu dữ liệu nhưng lại có hai sự khác biệt quan trọng: Đầu tiên, List không thể thay đổi, có nghĩa những phần tử trong một List không thể thay đổi được bằng phép gán.","text":"&nbsp;&nbsp;&nbsp;&nbsp;List trong scala gần tương tự như mảng, vì mọi phần tử đều cùng kiểu dữ liệu nhưng lại có hai sự khác biệt quan trọng: Đầu tiên, List không thể thay đổi, có nghĩa những phần tử trong một List không thể thay đổi được bằng phép gán. Thứ hai, List đại diện cho một danh sách liên kết các phần tử, trong khi đó các phần tử của array(mảng) đước xếp cạnh, liên tiếp với nhau. Kiểu của một List được viết duới dạng : List[T]. Bạn hãy xem thử ví dụ dưới đây, một vài List được định nghĩa cho các kiểu dữ liệu khác nhau. 12345678910111213141516// List of Stringsval fruit: List[String] = List(\"apples\", \"oranges\", \"pears\")// List of Integersval nums: List[Int] = List(1, 2, 3, 4)// Empty List.val empty: List[Nothing] = List()// Two dimensional listval dim: List[List[Int]] = List( List(1, 0, 0), List(0, 1, 0), List(0, 0, 1) ) Tất cả List được định nghĩa với hai khối cơ bản là :: và Nil ở cuối. Nil cũng biểu thị một danh sách trống. Tất cả List trên được định nghĩa như sau: 12345678910// List of Stringsval fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil))// List of Integersval nums = 1 :: (2 :: (3 :: (4 :: Nil)))// Empty List.val empty = Nil// Two dimensional listval dim = (1 :: (0 :: (0 :: Nil))) :: (0 :: (1 :: (0 :: Nil))) :: (0 :: (0 :: (1 :: Nil))) :: Nil Vừa rồi là một số giới thiệu sơ lược của mình về List trong Scala. Tiếp sau đây chúng ta sẽ đi tìm hiểu sâu hơn về một số cách thao tác và phương thức sử dụng trong List Thao tác cơ bản với ListTất cả thao tác trên List được thể hiện theo ba phương thức sau đây: No Phương thức và Mô tả 1 head: Phương thức này trả về phần tử đầu tiên của list. 2 tail: Phương thức này trả về 1 danh sách gồm tất cả phần tử ngoại trừ phần tử đầu tiên. 3 isEmpty: Phương thức này trả về true nếu list rỗng, và ngược lại trả về false. Ví dụ sau cho ta thấy cách dùng các phương thức trên. Ví dụ: 12345678910 object Demo &#123; def main(args: Array[String]) &#123; val fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) val nums = Nil println( \"Head of fruit : \" + fruit.head ) println( \"Tail of fruit : \" + fruit.tail ) println( \"Check if fruit is empty : \" + fruit.isEmpty ) println( \"Check if nums is empty : \" + nums.isEmpty ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1234Head of fruit : applesTail of fruit : List(oranges, pears)Check if fruit is empty : falseCheck if nums is empty : true Ghép nối các ListBạn có thể dùng hoặc phép toán ::: hoặc phương thức List.:::() hoặc List.concat() để thêm hai hoặc nhiều List trở lên. Vui lòng khám phá ví dụ dưới đây Ví dụ123456789101112131415object Demo &#123; def main(args: Array[String]) &#123; val fruit1 = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) val fruit2 = \"mangoes\" :: (\"banana\" :: Nil) // dùng 2 hay nhiều list với toán tử ::: var fruit = fruit1 ::: fruit2 println( \"fruit1 ::: fruit2 : \" + fruit ) // dùng 2 list với phương thức Set.:::() fruit = fruit1.:::(fruit2) println( \"fruit1.:::(fruit2) : \" + fruit ) // truyền hai hay nhiều list làm tham số fruit = List.concat(fruit1, fruit2) println( \"List.concat(fruit1, fruit2) : \" + fruit ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Những lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả123fruit1 ::: fruit2 : List(apples, oranges, pears, mangoes, banana)fruit1.:::(fruit2) : List(mangoes, banana, apples, oranges, pears)List.concat(fruit1, fruit2) : List(apples, oranges, pears, mangoes, banana) Tạo List đồng nhấtBạn có thể dùng phương thức List.fill() để tạo một 0 hoặc nhiều bản sao của các phần tử . Hãy thử chương trình ví dụ sau đây. Ví dụ:123456789object Demo &#123; def main(args: Array[String]) &#123; val fruit = List.fill(3)(\"apples\") // Repeats apples three times. println( \"fruit : \" + fruit ) val num = List.fill(10)(2) // Repeats 2, 10 times. println( \"num : \" + num ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:12fruit : List(apples, apples, apples)num : List(2, 2, 2, 2, 2, 2, 2, 2, 2, 2) Tạo bảng một hàmBạn có thể dùng một hàm cùng với phương thức List.tabulate() để tác dụng lên tất cả phần tử của List trước khi tạo bảng List. Tham số của hàm này giống như phương thức List.fill: Tham số thứ nhất cho biết kích thước List cần tạo, và tham số thứ hai mô tả các phần tử của List. Sự khác biệt duy nhất là thay vì phần tử cố định , chúng được tính từ một hàm. Thử chương trình ví dụ sau đây Ví dụ:123456789object Demo &#123; def main(args: Array[String]) &#123; // Creates 5 elements using the given function. val squares = List.tabulate(6)(n =&gt; n * n) println( \"squares : \" + squares ) val mul = List.tabulate( 4,5 )( _ * _ ) println( \"mul : \" + mul ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả123squares : List(0, 1, 4, 9, 16, 25)mul : List(List(0, 0, 0, 0, 0), List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8), List(0, 3, 6, 9, 12)) Đảo ngược thứ tự phần tử trong ListBạn có thể dùng phương thức List.reverse để đảo ngược tất cả phần tử trong danh sách. Ví dụ sau đây cho thấy cách dùng nó. Ví dụ:1234567object Demo &#123; def main(args: Array[String]) &#123; val fruit = \"apples\" :: (\"oranges\" :: (\"pears\" :: Nil)) println( \"Before reverse fruit : \" + fruit ) println( \"After reverse fruit : \" + fruit.reverse ) &#125;&#125; Lưu chương trình trên trong tập tin Demo.scala. Các Lệnh sau được dùng để biên dịch và thực thi chương trình này. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:12Before reverse fruit : List(apples, oranges, pears)After reverse fruit : List(pears, oranges, apples) Các phương thức của List trong scalaSau đây là những phương thức quan trọng khi bạn dùng khi thao tác với các List. Đối với một danh sách hoàn chỉnh các phương thức có sẵn, hãy kiểm tra tài liệu chính thức của Scala. Sr.No Phương thức và mô tả 1 scala def +(elem: A): List[A] Thêm một phần tử vào đầu list 2 def :::(prefix: List[A]): List[A] Thêm những phần tử của list được truyền, vào trước list ban đầu 3 def ::(x: A): List[A] Thêm một phần tử x vào đầu của list 4 def addString(b: StringBuilder): StringBuilder Gán tất cả phần tử của list vào chuỗi StringBuilder 5 def addString(b: StringBuilder, sep: String): StringBuilder Gán tất cả phần tử của list vào chuỗi StringBuilder b và ngăn cách lần lượt bởi chuỗi sep 6 def apply(n: Int): A Chỉ định và trả về một phần tử bởi chỉ số của nó trong list 7 def contains(elem: Any): Boolean Kiểm tra giá trị được truyền có là một phần tử trong list không. 8 def copyToArray(xs: Array[A], start: Int, len: Int): Unit Sao chép tất cả phần tử của list sang 1 mảng. Tham số cần truyền thêm là vị trí bắt đầu được sao chép sang trong mảng, và độ dài của list. 9 def distinct: List[A] Trả về một list mới từ list đã cho mà không chứa bất kỳ phần tử trùng nào. 10 def drop(n: Int): List[A] Trả về list chứa tất cả phần tử ngoại trừ n phần tử đầu tiên. 11 def dropRight(n: Int): List[A] Trả về list chứa tất cả phần tử ngoại trừ n phần tử cuối cùng. 12 def endsWith[B](that: Seq[B]): Boolean Kiểm tra list có kết thúc với danh sách Seq[] truyền vào hay không. 13 def equals(that: Any): Boolean Phương thức tương tự với các danh sách tùy ý. So sánh danh sách này với một số đối tượng khác. 14 def filter(p: (A) =&gt; Boolean): List[A] Trả về tất cả phần tử trong list thỏa mãn vị từ. 15 def foreach(f: (A) =&gt; Unit): Unit Áp dụng hàm f cho tất cả các phần tử của list. 16 def head: A Chỉ định phần tử đầu tử đầu tiên của list. 17 def indexOf(elem: A, from: Int): Int Tìm vị trí xuất hiện đầu tiên của giá trị A trong list ,kể từ vị trí from trở đi. 18 def init: List[A] Trả về list chứa tất cả phần tử ngoại trừ phần tử cuối cùng. 19 def isEmpty: Boolean Kiểm tra xem list có rỗng không 20 def iterator: Iterator[A] Tạo một trình lặp mới trên tất cả phần tử có trong đối tượng iterable có thể lặp 21 def last: A Trả về phần tử cuối cùng 22 def lastIndexOf(elem: A, end: Int): Int Tìm vị trí xuất hiện cuối cùng của một số giá trị trong list ,trước hoặc tại vị trí end . 23 def length: Int Trả về độ dài của list. 24 def map[B](f: (A) =&gt; B): List[B] Trả về một list mới bằng việc áp dụng hàm f cho tất cả phần tử của list. 25 def max: A Tìm phần tử lớn nhất. 26 def min: A Tìm phần tử nhỏ nhất. 27 def mkString: String Hiển thị ra tất cả phần tử của list dưới dạng một chuỗi. 28 def mkString(sep: String): String Hiển thị ra tất cả phần tử của list trong một chuỗi dùng 1 chuỗi ngăn cách sep 29 def reverse: List[A] Trả về một list mới với các phần tử được đảo ngược. 30 def sorted[B &gt;: A]: List[A Sắp xếp list theo một thứ tự. 31 def startsWith[B](that: Seq[B], offset: Int): Boolean Kiểm tra xem list có chứa danh sách truyền vào tại một vị trí offset không. 32 def sum: A Tính tổng tất cả phần tử của tập hợp. 33 def tail: List[A] Trả về tất cả phần tử ngoại trừ phần tử đầu tiên. 34 def take(n: Int): List[A] Trả về n phần tử đầu tiên. 35 def takeRight(n: Int): List[A] Trả về n phần tử cuối cùng. 36 def toArray: Array[A] Ép kiểu list sang kiểu mảng array. 37 def toBuffer[B &gt;: A]: Buffer[B] Ép kiểu list sang một bộ đệm có thể thay đổi. 38 def toMap[T, U]: Map[T, U] Chuyển đổi list sang một map 39 def toSeq: Seq[A] Chuyển đổi list sang một danh sách sequence. 40 def toSet[B &gt;: A]: Set[B] Chuyển đổi list sang một Set. 41 def toString(): String Chuyển đổi list sang một chuỗi. Nguồn tham khảohttps://www.tutorialspoint.com/scala/scala_lists.htm Biên tập: Nguyễn Đình Cường","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Giới thiệu về Option trong Scala","slug":"scala-options","date":"2018-10-15T10:07:20.000Z","updated":"2019-01-25T03:50:25.001Z","comments":true,"path":"2018/10/15/scala-options/","link":"","permalink":"https://scala-play.com/2018/10/15/scala-options/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;Option[T] là một vùng chứa 0 hoặc một phần tử của một kiểu đã cho. Một Option[T] có thể là đối tượng Some[ T ] hoặc None, biểu thị giá trị bị thiếu. Ví dụ, phương thức get của Map trong Scala tạo ra Some (value) nếu một giá trị tương ứng với một khóa đã cho đã được tìm thấy, hoặc None nếu khóa đã cho không được định nghĩa trong Map.","text":"&nbsp;&nbsp;&nbsp;&nbsp;Option[T] là một vùng chứa 0 hoặc một phần tử của một kiểu đã cho. Một Option[T] có thể là đối tượng Some[ T ] hoặc None, biểu thị giá trị bị thiếu. Ví dụ, phương thức get của Map trong Scala tạo ra Some (value) nếu một giá trị tương ứng với một khóa đã cho đã được tìm thấy, hoặc None nếu khóa đã cho không được định nghĩa trong Map. Kiểu Option được dùng thường xuyên trong chương trình scala và bạn có thể so sánh nó với giá trị null có sẵn trong Java để chỉ không có giá trị. Ví dụ , phương thức get trong java.util.HashMap trả về giá trị được lưu trong HashMap ,hoặc null nếu giá trị không được tìm thấy. Giả sử chúng ta có một phương thức lấy một bản ghi từ cơ sở dữ liệu dựa trên khóa chính. 1def findPerson(key: Int): Option[Person] Phương thức này sẽ trả về Some[Person] nếu bản ghi được tìm thấy hoặc None nếu bản ghi không được tìm thấy. Chúng ta cùng theo dõi chương trình sau đây. Ví dụ1234567object Demo &#123; def main(args: Array[String]) &#123; val capitals = Map(\"France\" -&gt; \"Paris\", \"Japan\" -&gt; \"Tokyo\") println(\"capitals.get( \\\"France\\\" ) : \" + capitals.get( \"France\" )) println(\"capitals.get( \\\"India\\\" ) : \" + capitals.get( \"India\" )) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12capitals.get( &quot;France&quot; ) : Some(Paris)capitals.get( &quot;India&quot; ) : None Cách phổ biến nhất để lấy các giá trị tùy ý sang một bên là thông qua a pattern match. Ví dụ, hãy thử chương trình sau. Ví dụ1234567891011object Demo &#123; def main(args: Array[String]) &#123; val capitals = Map(\"France\" -&gt; \"Paris\", \"Japan\" -&gt; \"Tokyo\") println(\"show(capitals.get( \\\"Japan\\\")) : \" + show(capitals.get( \"Japan\")) ) println(\"show(capitals.get( \\\"India\\\")) : \" + show(capitals.get( \"India\")) ) &#125; def show(x: Option[String]) = x match &#123; case Some(s) =&gt; s case None =&gt; \"?\" &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12show(capitals.get( &quot;Japan&quot;)) : Tokyoshow(capitals.get( &quot;India&quot;)) : ? Qua phần trên, mình đã giới thiệu qua và các bạn đã phần nào hiểu được sơ lược về cách sử dụng Option trong scala. Bây giờ chúng ta hãy cùng đi tìm hiểu sâu hơn về các phương thức thường xuyên được sử dụng trong Option. Dùng phương thức getOrElse() &nbsp;&nbsp;&nbsp;&nbsp; Sau đây là chương trình ví dụ để chỉ cách sử dụng phương thức getOrElse () để truy cập một giá trị hoặc một giá trị mặc định khi không có giá trị nào. Ví dụ12345678object Demo &#123; def main(args: Array[String]) &#123; val a:Option[Int] = Some(5) val b:Option[Int] = None println(\"a.getOrElse(0): \" + a.getOrElse(0) ) println(\"b.getOrElse(10): \" + b.getOrElse(10) ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12a.getOrElse(0): 5b.getOrElse(10): 10 Dùng phương thức isEmpty() &nbsp;&nbsp;&nbsp;&nbsp; Sau dây là chương trình ví dụ để chỉ cách dùng phương thức isEmpty() để kiểm tra Option là None hay không Ví dụ12345678object Demo &#123; def main(args: Array[String]) &#123; val a:Option[Int] = Some(5) val b:Option[Int] = None println(\"a.isEmpty: \" + a.isEmpty ) println(\"b.isEmpty: \" + b.isEmpty ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả12a.isEmpty: falseb.isEmpty: true Những phương thức Option trong Scala &nbsp;&nbsp;&nbsp;&nbsp; Sau đây là các phương thức quan trọng mà bạn có thể sử dụng khi lựa chọn Options. Để biết danh sách đầy đủ các phương pháp có sẵn, vui lòng kiểm tra tài liệu chính thức của Scala. Sr.No Phương thức và mô tả 1 def get: A Trả về giá trị của option 2 def isEmpty: Boolean Trả về true nếu option là None, ngược lại thì false 3 def productArity: Int Kích thước của kết quả này. Đối với một kết quả A(x_1, …, x_k) trả về k. 4 def productElement(n: Int): Any Phần tử thứ n của kết quả này , dựa trên 0. Nói cách khác, đối với một kết quả A(x_1, …, x_k), trả về x_(n + 1) trong đó 0 &lt; n &lt; k. 5 def exists(p: (A) =&gt; Boolean): Boolean Trả về true nếu option này khác rỗng và hàm p trả về true khi áp dụng cho giá trị của Option này. Nếu không, trả về false. 6 def filter(p: (A) =&gt; Boolean): Option[A] Trả về Option này nếu nó khác rỗng, và áp dụng hàm p cho giá trị của Option này trả về true. Nếu không, trả về None. 7 def filterNot(p: (A) =&gt; Boolean): Option[A] Trả về Option này nếu nó khác rỗng, và áp dụng hàm p cho giá trị của Option này trả về false. Nếu không, trả về None. 8 def flatMapB =&gt; Option[B]): Option[B] Trả về kết quả của áp dụng hàm f cho giá trị của Option nếu Option này khác rỗng. Trả về None nếu Option này rỗng. 9 def foreachU =&gt; U): Unit Áp dụng hàm f cho giá trị của option ,nếu nó khác rỗng. Ngược lại, không làm gì cả 10 def getOrElseB &gt;: A: B Trả về giá trị của option nếu option này khác rỗng, ngược lại trả về kết quả của đánh giá default mặc định. 11 def isDefined: Boolean Trả về true nếu option này là một thể hiện của kiểu Some , ngược lại false. 12 def iterator: Iterator[A] Trả về một trình lặp singleton trả về giá trị của Option nếu nó khác rỗng, hoặc một trình lặp rỗng nếu option rỗng. 13 def mapB =&gt; B): Option[B] Trả về một Some chứa kết quả của áp dụng hàm f cho giá trị của Option này nếu Option này khác rỗng. Nếu không, trả về None. 14 def orElseB &gt;: A: Option[B] Trả về Option này nếu nó khác rỗng , không thì trả về kết quả của đánh giá thay thế alternative. 15 def orNull Trả về giá trị của option nếu nó khác rỗng, hoặc trả về null nếu nó rỗng. Nguồn tham khảohttps://www.tutorialspoint.com/scala/scala_options.htm Biên tập: Nguyễn Đình Cường","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Tích hợp Gitlab-CICD vào dự án thực tế","slug":"intergrated-cicd","date":"2018-10-11T07:27:20.000Z","updated":"2019-01-25T04:20:49.676Z","comments":true,"path":"2018/10/11/intergrated-cicd/","link":"","permalink":"https://scala-play.com/2018/10/11/intergrated-cicd/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;Gần đây, team Best Solution đã tích hợp được Gitlab-CICD vào dự án Green-Blue để tự động hóa quá trình Build, Deploy ứng dụng lên Staging. Dưới đây là hướng dẫn về cách tích hợp Gitlab-CICD cho những dự án khác. Trong hướng dẫn này, mình sử dụng GitLab Community Edition 8.16.3 và Gitlab Runner 1.11.1","text":"&nbsp;&nbsp;&nbsp;&nbsp;Gần đây, team Best Solution đã tích hợp được Gitlab-CICD vào dự án Green-Blue để tự động hóa quá trình Build, Deploy ứng dụng lên Staging. Dưới đây là hướng dẫn về cách tích hợp Gitlab-CICD cho những dự án khác. Trong hướng dẫn này, mình sử dụng GitLab Community Edition 8.16.3 và Gitlab Runner 1.11.1 1. Tích hợp Gitlab Runner và thêm biến môi trường cho dự án trên Gitlab&nbsp;&nbsp;&nbsp;&nbsp;Để có thể tiến hành quá trình Build-Deploy, Gitlab sử dụng một server có tên là Runner. Tại đây, ứng dụng của chúng ta sẽ được Build,Test, sau đó được Deploy lên server. &nbsp;&nbsp;&nbsp;&nbsp;Hiện tại, Gitlab cung cấp các Shared Runner miễn phí cho chúng ta. Nhưng vì yếu tố bảo mật và đảm bảo hiệu năng, chúng ta nên tự cài đặt một Runner Server riêng phục vụ cho các dự án của công ty. &nbsp;&nbsp;&nbsp;&nbsp;Trong team Best Solution, mình đã cài đặt một Runner Server có tên là the runner. Chúng ta chỉ cần tích hợp Runner vào dự án là có thể sử dụng được. 1.1 Tích hợp Gitlab RunnerChúng ta vào mục Runner (1) của dự án, sẽ thấy màn hình như hình phía dưới. &nbsp;&nbsp;&nbsp;&nbsp;Ở đây có hai phần, Specific Runners và Shared Runners. Như đã nói ở trên, chúng ta chỉ quan tâm tới Specific Runners. Nhìn vào (2), các bạn sẽ thấy một Runner mà mình đã cài đặt sẵn. Để tích hợp Runner vào dự án, chỉ cần nhấn vào nút Enable for this project như (3) là xong. 1.2 Thêm biến môi trường cho dự ánĐể thêm biến môi trường, chúng ta vào mục Variables (1). &nbsp;&nbsp;&nbsp;&nbsp;Đây chính là nơi các bạn khai báo biến môi trường với Gitlab và Runner sẽ sử dụng những biến môi trường này. Có một câu hỏi là: tại sao lại cần biến môi trường ?&nbsp;&nbsp;&nbsp;&nbsp;Mình sẽ lấy ví dụ để trả lời câu hỏi này, các bạn nhìn vào (3). Ở đây mình khai báo một biến môi trường với tên là SSH_PRIVATE_KEY và giá trị của nó sẽ là tất cả các ký tự trong file key mà các bạn sử dụng để ssh lên server khi tiến hành Deploy ứng dụng. Nếu chúng ta không khai báo một key ở đây, thì Runner Server sẽ không thể tiến hành quá trình Deploy được.&nbsp;&nbsp;&nbsp;&nbsp;Với một dự án mới, sẽ không có biến môi trường nào hiển thị ở đây cả. Các bạn sẽ phải tự thêm vào. Đối với team Best Solution, chỉ cần thêm biến SSH_PRIVATE_KEY là đủ. 2. Viết script triển khai ứng dụng lên server&nbsp;&nbsp;&nbsp;&nbsp;Trên server, chúng ta tạo một thư mục để triển khai ứng dụng. Ở đây, mình lấy ví dụ với ứng dụng Gree-Blue, thư mục sẽ giống như hình bên dưới:green-blue-cicd/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ config/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ database.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ log/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ application.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ script/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ deploy.sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ source/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ green-blue-STAGING-20181005172440/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ version/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ green-blue-STAGING-20181005172440.zip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|__ … Mình sẽ giới thiệu qua mục đích của từng folder trong thư mục chính green-blue-cicd/. Đầu tiên là folder config/, đây là nơi chứa config của ứng dụng. Hiện tại, mình chỉ để config của database trong đó. Chúng ta cần một file config database mẫu để dùng cho quá trình triển khai ứng dụng. Thứ hai là folder log/, đây là nơi chứa log của ứng dụng trong quá trình chạy. Thứ ba là folder script/, mình để script triển khai ứng dụng ở đây. Folder source/ là nơi chứa mã nguồn được giải nén ra từ các phiên bản của ứng dụng nằm bên trong folder version/. Điều quan tâm nhất là script deploy.sh sẽ được viết như thế nào …123456789101112131415161718192021#!/bin/bash# define app nameAPP_NAME=\"green-blue\"# unzip source-codecd /root/web/green-blue-cicd/versionunzip $1.zip -d ../source/# re-config applicationcd /root/web/green-blue-cicd/source/$1/confmv mailer.conf.example mailer.confmv silhouette.conf.example silhouette.confcp /root/web/green-blue-cicd/config/database.conf ./# kill process of prev-versionpid=$(ps -p $(lsof -ti tcp:9000) o pid=)kill -9 $pid# run server &amp; write log filecd /root/web/green-blue-cicd/source/$1/bin/nohup ./$APP_NAME -Dplay.http.secret.key=xxxxxxxxx -Dplay.evolutions.db.default.autoApply=true -Dhttp.port=9000 &gt; /root/web/green-blue-cicd/log/application.log &amp; &nbsp;&nbsp;&nbsp;&nbsp;Hình ảnh phía trên là nội dung file deploy.sh dùng để triển khai Green-Blue. Trong đó, $1 là tham số truyền vào khi chạy script deploy.sh, ở đây $1 đại diện cho tên của version muốn triển khai. Chúng ta có thể thấy, nội dung file gồm 4 phần:- (1) Giải nén source-code- (2) Cấu hình cho ứng dụng, trong đó có bước lấy file database.conf từ file mẫu ban đầu.- (3) Bỏ bản triển khai trước đó, nó đang chạy ở cổng 9000- (4) Triển khai một version mới và ghi log vào application.log &nbsp;&nbsp;&nbsp;&nbsp;Để triển khai CICD cho một dự án khác, các bạn chỉ cần giữ nguyên cấu trúc thư mục và thay đổi nội dung các file bên trong của nó. Chính xác là chỉ cần thay đổi nội dung file database.conf và file deploy.sh. Nội dung file database.conf sẽ được thay đổi tùy vào các dự án khác nhau. Đối với deploy.sh, chúng ta cần làm 2 việc:- Thay tên của các đường dẫn- Thay tên của ứng dụng trong bước (4). 3. Viết file .gitlab.yml&nbsp;&nbsp;&nbsp;&nbsp;Đầu tiên, chúng ta sẽ đi xem .gitlab-ci.yml của dự án Green-Blue ở đây.Chúng ta sẽ thấy có các phần chính sau: image: docker image được dùng cho quá trình Build - Deploy stages: nơi liệt kê các quá trình được thực thi variables: nơi khai báo các biến môi trường cache: nơi khai báo các thư mục mà bạn muốn cache lại sau mỗi lần Build - Deploy staging: quá trình triển khai ứng dụng lên STAGING &nbsp;&nbsp;&nbsp;&nbsp;Khi viết .gitlab-ci.yml cho một dự án mới, chúng ta chỉ cần quan tâm tới staging, đây là nơi thực thi các câu lệnh tiến hành quá trình Build - Deploy ứng dụng. Các câu lệnh thực thi được chia làm hai phần: a) before_script: các câu lệnh chuẩn bị cho quá trình Deploy, bao gồm các bước:(1) Tạo tên version mới cho ứng dụng12345678# Create VERSION_NAME## Set TIME ZONE- TZ=Asia/Ho_Chi_Minh- ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone## Set VERSION_NAME- export VERSION_NAME=$(date +'%Y%m%d%H%M%S')- echo \"VERSION_NAME is green-blue-STAGING-$&#123;VERSION_NAME&#125;\"- apt-get update -y (2) Cài đặt sbt12345# Install SBT- echo \"deb http://dl.bintray.com/sbt/debian /\" | tee -a /etc/apt/sources.list.d/sbt.list- apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 642AC823- apt-get update -y- apt-get install sbt -y (3) Thay đổi tên version cho ứng dụng123# Change BUILD VERSION- sed -i 's/BUILD_VERSION/'\"STAGING-$&#123;VERSION_NAME&#125;\"'/g' build.sbt- sed -i 's/BUILD_VERSION/'\"green-blue-STAGING-$&#123;VERSION_NAME&#125;\"'/g' public/javascripts/zxcvbnShim.js (4) Thực hiện quá trình Build1- sbt dist (5) Cài đặt ssh12345678# Setup SSH- 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )'# Run ssh-agent (inside the build environment)- eval $(ssh-agent -s)# Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store- ssh-add &lt;(echo \"$SSH_PRIVATE_KEY\")- mkdir -p ~/.ssh- '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' (6) Chuyển mã nguồn sau khi Build lên Staging server12# Send FILE to remote server- scp target/universal/green-blue-STAGING-$&#123;VERSION_NAME&#125;.zip root@133.xx.xxx.xxx:/root/web/green-blue-cicd/version b) script: các câu lệnh của quá trình Deploy, đây là việc ssh lên Staging và thực thi deploy.sh123- echo \"DEPLOY to STAGING server ...\"# Deploy- ssh root@133.xx.xxx.xxx \"sh /root/web/green-blue-cicd/script/deploy.sh green-blue-STAGING-$&#123;VERSION_NAME&#125;\" Chúng ta sẽ phải thay đổi một chút trong khi viết file .gitlab-ci.yml mới.Đối với before_script, chúng ta chỉ cần thay đổi ở các bước (3) và (6): Với bước (3) Thay đổi version := “1.x.x” trong build.sbt thành version := “BUILD_VERSION” Thêm câu lệnh console.log(“Current version is “ + “BUILD_VERSION”) vào đầu file zxcvbnShim.js Với bước (6) thay đổi cái tên green-blue trong đường dẫn target/universal/green-blue-STAGING-${VERSION_NAME}.zip thành tên dự án của bạn. thay đổi đường dẫn /root/web/green-blue-cicd/version cho đúng với đường dẫn với thư mục version/ trên server của bạn. Đối với script: Thay đổi đường dẫn /root/web/green-blue-cicd/script/deploy.sh cho đúng với đường dẫn tới file deploy.sh của bạn trên server. Thay đổi tên green-blue trong green-blue-STAGING-${VERSION_NAME} thành tên dự án của bạn. &nbsp;&nbsp;&nbsp;&nbsp;Đến đây, chúng ta chỉ việc push những gì vừa làm lên branch dev là hoàn thành xong việc tích hợp Gitlab-CICD cho dự án mới. Tác giả: Cao Văn Long","categories":[{"name":"ci/cd","slug":"ci-cd","permalink":"https://scala-play.com/categories/ci-cd/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://scala-play.com/tags/tutorial/"}]},{"title":"Giới thiệu về Tuples trong Scala","slug":"scala-tuples","date":"2018-10-08T10:37:14.000Z","updated":"2019-01-25T03:50:42.689Z","comments":true,"path":"2018/10/08/scala-tuples/","link":"","permalink":"https://scala-play.com/2018/10/08/scala-tuples/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp; Trong Scala, Tuple dùng để gộp một số lượng phần tử cố định cùng với nhau. Không như array (mảng) và list (danh sách), một tuple có thể chứa object (đối tượng) với các kiểu dữ liệu khác nhau và chúng không thay đổi được giá trị. Sau đây là ví dụ về tuple lưu kiểu nguyên và kiểu chuỗi. Đây là một cách khai báo ngắn gọn: 1val t = (1, \"hello\")","text":"&nbsp;&nbsp;&nbsp;&nbsp; Trong Scala, Tuple dùng để gộp một số lượng phần tử cố định cùng với nhau. Không như array (mảng) và list (danh sách), một tuple có thể chứa object (đối tượng) với các kiểu dữ liệu khác nhau và chúng không thay đổi được giá trị. Sau đây là ví dụ về tuple lưu kiểu nguyên và kiểu chuỗi. Đây là một cách khai báo ngắn gọn: 1val t = (1, \"hello\") Cách khai báo cụ thể sẽ giống như sau:1val t = new Tuple2(1, \"hello\") Kiểu thực sự của tuple phụ thuộc vào số lượng và các phần tử và kiểu của các phần tử đó.Do đó kiểu của (99, “Luftballons”) là Tuple2[Int, String]. Kiểu của (‘u’, ‘r’, “the”, 1, 4, “me”) là Tuple6[Char, Char, String, Int, Int, String]. Tuples có kiểu Tuple1 ,Tuple2, Tuple3… .Hiện tại tuples có thể chứa tối đa 22 phần tử ,nếu muốn nhiều hơn ,bạn có thể sử dụng Collection khác ngoài tuple. Đối với mỗi kiểu TupleN , trong đó 1&lt;= N &lt;= 22 Scala định nghĩa một số phương thức truy cập phần tử với đinh nghĩa sau- 1val t = (4,3,2,1) Để truy cập các phần tử của tuple t, bạn có thể dùng phương thức t._1 để truy cập phần tử đầu tiên , t._2 để truy cập phần tử thứ hai, và tương tự . Ví dụ, biểu thức sau đây tính tổng các phần tử của tuple t. 1val sum = t._1 + t._2 + t._3 + t._4 Bạn có thể dùng Tuple để viết một phương thức lấy kiểu List[Double] làm tham số và trả về biến biến count , biến tổng sum , và tổng bình phương ,được trả về dưới kiểu Tuple 3 phần tử , kiểu Tuple3[Int, Double, Double] .Chúng cũng hữu ích khi truyền danh sách các giá trị dữ liệu dưới dạng thông điệp giữa các tác nhân trong lập trình đồng thời. Thử chương trình ví dụ sau: Ví dụ:1234567object Demo &#123; def main(args: Array[String]) &#123; val t = (4,3,2,1) val sum = t._1 + t._2 + t._3 + t._4 println( \"Sum of elements: \" + sum ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt:12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả:1Sum of elements: 10 Phần trên là những giới thiệu qua của mình về Tuple trong Scala. Bây giờ chúng ta sẽ đi tìm hiểu một vài phương thức thường xuyên được sử dụng trong Tuple. Phép lặp trên Tuple Bạn có thể dùng phương thức Tuple.productIterator() để lặp qua hết tất cả các phần tử của Tuple.Thử ví dụ sau để thực hiện phép lặp trên tuples. Ví dụ:123456object Demo &#123; def main(args: Array[String]) &#123; val t = (4,3,2,1) t.productIterator.foreach&#123; i =&gt;println(\"Value = \" + i )&#125; &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1234Value = 4Value = 3Value = 2Value = 1 Chuyển đổi thành chuỗi Bạn có thể sử dụng phương thức Tuple.toString () để nối tất cả các phần tử của tuple sang kiểu chuỗi. Hãy thử chương trình ví dụ sau để chuyển đổi thành Chuỗi. Ví dụ12345object Demo &#123; def main(args: Array[String]) &#123; val t = new Tuple3(1, \"hello\", Console) println(\"Concatenated String: \" + t.toString() )&#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1Concatenated String: (1,hello,scala.Console$@281acd47) Đảo các phần tử trong TupleBạn có thể sử dụng phương thức Tuple.swap để hoán đổi các phần tử của Tuple2.Hãy thử chương trình ví dụ sau để hoán đổi các phần tử. Ví dụ123456object Demo &#123; def main(args: Array[String]) &#123; val t = new Tuple2(\"Scala\", \"hello\") println(\"Swapped Tuple: \" + t.swap ) &#125;&#125; Lưu chương trình trên vào file Demo.scala. Lệnh sau đây được dùng để biên dịch và thực thi chương trình Demo. Cài đặt12\\&gt;scalac Demo.scala\\&gt;scala Demo Kết quả1Swapped tuple: (hello,Scala) Nguồn tham khảohttps://www.tutorialspoint.com/scala/scala_tuples.htm Biên tập: Nguyễn Đình Cường","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]},{"title":"Sử dụng Gitlab-CI/CD cơ bản","slug":"git-lab","date":"2018-10-06T03:48:07.000Z","updated":"2019-01-25T03:48:13.795Z","comments":true,"path":"2018/10/06/git-lab/","link":"","permalink":"https://scala-play.com/2018/10/06/git-lab/","excerpt":"1. Các chức năng chính Tự động Build và Deploy lên Staging (đã sử dụng được) Tự động Build và Deploy lên Production (đang phát triển) - Chức năng tự động Build và Deploy lên Staging sẽ được kích hoạt khi merge code vàobranch “dev” hoặc push code lên branch “dev”.","text":"1. Các chức năng chính Tự động Build và Deploy lên Staging (đã sử dụng được) Tự động Build và Deploy lên Production (đang phát triển) - Chức năng tự động Build và Deploy lên Staging sẽ được kích hoạt khi merge code vàobranch “dev” hoặc push code lên branch “dev”. - Chức năng tự động Build và Deploy lên Production sẽ được kích hoạt khi merge code vàobranch “master” hoặc push code lên branch “master”. 2. Cách sử dụngBước 1: merge code vào branch “dev” hoặc push code lên branch “dev” Bước 2: chờ quá trình Build - Deploy diễn raBước 2.1: Đầu tiên, chúng ta vào mục “Pipelines” để kiểm tra trạng thái của quá trình. Bước 2.2: Nhấn vào “running” để đi tới màn hình chi tiết của quá trình. Bước 2.3: ​ Nhấn vào “staging” để đi tới màn hình console - nơi hiển thị chi tiết quá trình build và deploy dự án lên Staging. - Sau bước này, chúng ta sẽ có kết quả của quá trình Build -&gt; Deploy. Sẽ có hai trường hợp xảy ra: Quá trình xảy ra lỗi: Gitlab-CI/CD sẽ báo trạng thái của quá trình sẽ hiển thị giống như . Hoặc hiển thị “ERROR: Job failed: exit code 1” trên màn hình console ở dòng cuối cùng. Quá trình diễn ra thành công: trạng thái sẽ là . Bước 3: xử lý kết quả của quá trình Build - Deploy Bước 3.1: N​ếu kết quả trả về là thành công . Chúng ta sẽ lên Staging server để xemkết quả, công việc triển khai coi như xong. Ngoài ra, chúng ta có thể xem chi tiết hơn bằngcách: - Vào mục “Builds” để xem tất cả các quá trình Build - Deploy đã thực hiện (bao gồm cả quátrình thực thi lại một lần Build - Deploy nào đó) - Vào mục “Environments” để xem các môi trường đã triển khai. Ở đây, chúng ta mới triểnkhai lên môi trường Staging. Môi trường Production sẽ được triển khai sau… Bước 3.2: Nếu kết quả trả lỗi, chúng ta nên đọc lại phần thông tin hiển thi ở màn hình console trước để tìm ra nguyên nhân. Sau đó đi tới mục “related-code” để xem chi tiết đoạn code nào đã gây lỗi cho hệ thống. Tác giả: Cao Văn Long","categories":[{"name":"ci/cd","slug":"ci-cd","permalink":"https://scala-play.com/categories/ci-cd/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"https://scala-play.com/tags/tutorial/"}]},{"title":"Higher Order Functions trong Scala","slug":"HOF-in-scala","date":"2018-10-02T13:08:24.000Z","updated":"2019-01-25T03:48:32.087Z","comments":true,"path":"2018/10/02/HOF-in-scala/","link":"","permalink":"https://scala-play.com/2018/10/02/HOF-in-scala/","excerpt":"Định nghĩa Higher Order FunctionHigher Order Function là function thỏa mãn ít nhất một trong hai điều kiện : Có ít nhất một tham số truyền vào là một function khác Kết quả trả về của HOF đó là một function khác. Với Higher Order Function, tính trừu tượng hóa, tái sử dụng chính là điểm mạnh.","text":"Định nghĩa Higher Order FunctionHigher Order Function là function thỏa mãn ít nhất một trong hai điều kiện : Có ít nhất một tham số truyền vào là một function khác Kết quả trả về của HOF đó là một function khác. Với Higher Order Function, tính trừu tượng hóa, tái sử dụng chính là điểm mạnh. Tính trừu tượng hóa (Abstraction)Hãy nghĩ đến dây chuyền lắp ráp một chiếc xe. Dây chuyền gồm bốn bộ phận: Bộ phận tạo bánh xe Bộ phận tạo khung xe Bộ phận tạo động cơ Bộ phận lắp ráp Bộ phận tạo bánh xe sẽ tạo ra bánh xe và chuyển qua bộ phận lắp. Tương tự như vậy, bộ phận tạo khung xe và bộ phân tạo động cợ sẽ tạo ra khung và động cơ, sau đó chuyển sang cho bộ phân lắp ráp. Bộ phận lắp ráp không cần phải biết bánh xe, khung xe hay động cơ xe được tạo ra như thế nào. Chức năng của bộ phận lắp ráp chỉ là ghép các thành phần để tạo ra chiếc xe mà thôi. Bộ phận lắp ráp chính là một HOF, nó nhận output của ba bộ phận còn lại để tạo ra output cho riêng nó. Có thể diễn giải như thế này: 123456789101112131415161718192021222324class BanhXe&#123;&#125; class KhungXe&#123;&#125; class DongCoXe&#123;&#125; // ham tao banh xe def taoBanhXe() = &#123; val banhXe = new BanhXe banhXe &#125; // ham tao khung xe def taoKhungXe() = &#123; val khungXe = new KhungXe khungXe &#125; // ham tao dong co xe def taoDongCoXe() = &#123; val dongCoXe = new DongCoXe dongCoXe &#125; // HOF function def lapRapXe(taoBanhXe(), taoKhungXe(), taoDongCoXe()) Từ ví dụ trên, chúng ta có thể hiểu tính trừu tượng hóa của HOF giúp che giấu chi tiết bên trong một function, làm giảm sự phức tạp. Vấn đề sẽ được xử lý ở một tầng cao hơn, trừu tượng hơn. Tính tái sử dụng (Reusable)Cũng sử dụng ví dụ về dây chuyền tạo ra một chiếc xe. Chúng ta xây dựng một dây chuyền sản xuất xe máy. Tuy nhiên, nếu phải tạo ra thêm một dây chuyền sản xuất xe hơi thêm vào thì sẽ như thế nào ? Tạo ra một dây chuyền mới là giải pháp đơn giản nhất nhưng lại tốn kém về chi phí. Chúng ta có thể bổ sung thêm cho bộ phận tạo bánh xe máy khả năng tạo ra bánh xe hơi. Tương tự như vậy, bộ phận tao khung xe và động cơ đều trang bị thiết bị tạo ra đồng thời linh kiện cho xe máy lẫn xe hơi. Như vậy, ba bộ phân trên đều được sử dụng tùy theo yêu cầu tạo ra sản phẩm. Đó chính là tính tái sử dụng. Cách sử dụng HOF trong ScalaMột bài toán đơn giản được đặt ra, hãy hình dung bạn đang là một ông chủ và muốn tăng lương cho nhân viên của mình. Tăng lương là việc bạn nhân số lương hiện tại của nhân viên với một hệ số nhất định. Bạn nghĩ rằng, việc tăng lương cần linh động do đó phải tạo ra nhiều cách tăng lương khác nhau. Với bài toán trên, chúng ta sẽ đi giải quyết như sau: Để tiện cho việc quản lý vấn đề tăng lương, bạn sử dụng một Object có tên là SalaryRaiser. Bạn có 3 mức tăng lương khác nhau, theo thứ tự tăng dần là: smallPromotion(), greatPromotion() và hugePromotion(). Ở mức smallPromotion, hệ số là 1.1 Ở mức smallPromotion, hệ số là logarit cơ số 10 của số lương hiện tại ứng với nhân viên đó. Ở mức smallPromotion, hệ số là số lương hiện tại của nhân viên đó. Theo cách thông thường, chúng ta sẽ dùng một vòng for để cập nhật giá trị lương của từng nhân viên. Sau đó, trả về danh sách lương của nhân viên sau khi đã cập nhật. Các bạn xem code phía dưới. 123456789101112131415161718192021222324object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * 1.1 &#125; salaries &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * math.log(salaries(i)) &#125; salaries &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; for (i &lt;- salaries.indices) &#123; salaries(i) = salaries(i) * salaries(i) &#125; salaries &#125;&#125; Với HOF, việc viết code trở nên dễ dàng và ngắn gọn hơn khá nhiều. Ở đây, chúng ta sẽ sử dụng một HOF đó là map(). Chúng ta truyền vào map() một function, chính function này sẽ giúp chúng ta thay đổi lương của mỗi nhân viên theo hệ số mong muốn. Hàm map() đã thể hiện tính linh hoạt thông qua việc định nghĩa cách xử lý từng phần tử trong Array. 123456789101112131415object SalaryRaiser &#123; def smallPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * 1.1) &#125; def greatPromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * math.log(salary)) &#125; def hugePromotion(salaries: Array[Double]): Array[Double] = &#123; salaries.map(salary =&gt; salary * salary) &#125;&#125; Hiện nay đối với Scala, map() là một trong những HOF được dùng nhiều nhất. Ngoài ra, các bạn có thể tìm hiểu thêm về các HOF khác như filter(), flatMap() … Nguồn tham khảo https://discuss.grokking.org/t/higher-order-functions-la-gi-va-d-c-s-d-ng-nh-th-nao/309 https://docs.scala-lang.org/tour/higher-order-functions.html Tác giả: Cao Văn Long","categories":[{"name":"scala","slug":"scala","permalink":"https://scala-play.com/categories/scala/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://scala-play.com/tags/basic/"}]}]}